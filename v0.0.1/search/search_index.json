{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pymatgen.io.espresso","text":"<p><code>pymatgen.io.espresso</code> is currently in pre-alpha testing, so not all features are implemented, the public API is subject to change, and not everything has been tested thoroughly. Development is in progress.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>...</li> </ul>"},{"location":"#planned-features-short-term","title":"Planned Features (short term)","text":"<ul> <li>...</li> </ul>"},{"location":"#planned-features-long-term","title":"Planned Features (long term)","text":"<ul> <li>... </li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"dev_notes/SUMMARY/","title":"SUMMARY","text":"<ul> <li>filproj Format</li> <li>projwfc.x Output File Comparison</li> </ul>"},{"location":"dev_notes/filproj_format/","title":"The format of <code>filproj</code>","text":""},{"location":"dev_notes/filproj_format/#preliminaries","title":"Preliminaries","text":"<ul> <li>The header is written by <code>PP/src/write_io_header.f90</code></li> <li>projections by <code>PP/src/write_proj.f90</code>, in the <code>write_proj_file</code> subroutine.</li> </ul> <p>If the calculation is colinear (no spin polarization) or noncolinear, the filename will be <code>filproj.projwfc_up</code>. If it's spin-polarized colinear, you get a second file <code>filproj.projwfc_down</code>.</p>"},{"location":"dev_notes/filproj_format/#header-format","title":"Header Format","text":"<p>Header (stuff in <code>{}</code> are just my comments):</p> <pre><code>{empty line}\nnr1x nr2x nr3x nr1 nr2 nr3 nat ntyp\nibrav celldm(1) ... celldm(6)\na1x a1y a1z {only if ibrav=0}\na2x a2y a2z {only if ibrav=0}\na3x a3y a3z {only if ibrav=0}\ngcutm dual ecutwfc 9 {last one is always 9}\nspecies_i species_symbol nelect {line repeated ntyp times}\natom_i x y z species_i {line repeated nat times}\nnatomwfc nkstot nbnd\nnoncolin lspinorb {only possible combinations: F F, T F, T T}\n</code></pre> Parameter Explanation <code>nr1x, nr2x, nr3x</code> Physical dimensions of charge density array <code>nr1, nr2, nr3</code> (Dense) FFT grid dimensions/true dimensions of charge density array <code>nat</code> Total number of atoms (same as <code>pw.x</code> input) <code>ntyp</code> Total number of species (same as <code>pw.x</code> input) <code>ibrav</code> Bravais lattice (same as <code>pw.x</code> input) <code>celldm(1) ... celldm(6)</code> The lattice constants and angles \\((a, b/a, c/a, \\cos\\alpha, \\cos\\beta, \\cos\\gamma)\\) in bohr units (same as <code>pw.x</code> input). Only <code>celldm(1)</code> is guaranteed to be nonzero, the rest may be 0 depending on <code>ibrav</code>. <code>a1x, a1y, a1z</code> x, y, z components of the first lattice vector in units of alat. Only present if <code>ibrav=0</code>. <code>a2x, a2y, a2z</code> x, y, z components of the second lattice vector in units of alat. Only present if <code>ibrav=0</code>. <code>a3x, a3y, a3z</code> x, y, z components of the second lattice vector in units of alat. Only present if <code>ibrav=0</code>. <code>gcutm</code> \\(E_\\text{cut}^{\\rho}/(2\\pi/a)^2\\), where \\(E_\\text{cut}^\\rho\\) = <code>ecutrho</code> and \\(a\\) = <code>alat</code>,in units of \\(\\text{Ry}\\times a_0^2\\). <code>dual</code> <code>ecutrho/ecutwfc</code> <code>ecutwfc</code> The wavefunction cutoff in Ry (same as <code>pw.x</code> input) <code>9</code> The number 9. It's always there for an unknown reason <code>species_i</code> Unique index (1 through <code>ntyp</code>) given to each unique species in the calculation <code>species_symbol</code> Symbol for the element given in the input file (<code>O</code>, <code>Fe</code>) <code>nelect</code> Number of valence electrons in the pseudopotential file for the species. <code>atom_i</code> Unique index (1 through <code>nat</code>) given to each atom in the calculation <code>x y z</code> Atom's position in cartesian coordinations, units of <code>alat</code> (regardless of what's in <code>pw.x</code>'s input). <code>species_i</code> The index giving the type of the atom, see above. <code>natomwfc</code> Number of total atomic wave functions (i.e., orbitals) available. Computed from the pseudopotential files <code>nkstot</code> Number of total \\(k\\)-points in the calculation. <code>nbnd</code> Number of bands (same as <code>pw.x</code> input). <code>noncolin</code> Whether the calculation is noncolinear (<code>T</code> or <code>F</code>, same as <code>pw.x</code> input) <code>lspinorb</code> Whether the calculation includes spin-orbit coupling (<code>T</code> or <code>F</code>, same as <code>pw.x</code> input)"},{"location":"dev_notes/filproj_format/#projections","title":"Projections","text":"<p>After the header, we end up with <code>natomwfc</code> sets of overlaps that schematically looks like this:</p> <pre><code>if noncolin and lspinorb:\n    state_i atom_i species_symbol orbital_label wfc_i l j mj\nelif noncolin and not lspinorb:\n    state_i atom_i species_symbol orbital_label wfc_i l m s_z\nelse:\n    state_i atom_i species_symbol orbital_label wfc_i l m \nfor k_i in range(k_init, k_final+1):\n    for band_i in range(1, nbnd+1):\n      k_i band_i overlap\n</code></pre> <p>(i.e., there is a total of <code>nkstot*nbnd+1</code> lines)</p> Parameter Explanation <code>noncolin</code> Given in the header, see above. <code>lspinorb</code> Given in the header, see above. <code>state_i</code> A unique index for an atomic state, from 1 to <code>natomwfc</code>. Also written to <code>projwfc.x</code> <code>stdout</code>. <code>atom_i</code> Given in the header, see above. <code>species_symbol</code> Symbol for the species (e.g., <code>Fe</code>, <code>Sr</code>, etc.). Given in the header, see above. <code>orbital_label</code> A label for the atomic orbital, e.g., <code>4S</code> or <code>5P</code> or <code>3D</code>. <code>wfc_i</code> A unique index for an atomic wfc of a given atom. A combination (<code>l</code>,<code>j</code>)or just <code>l</code> is considered unique. Prepended to the DOS files. <code>l</code> Orbital quantum number \\(l\\) <code>j</code> Orbital quantum number \\(j\\) <code>m</code> Index for the type of orbital, see table below. Not the magnetic quantum number \\(m_l\\). <code>s_z</code> Eigenvalue of \\(\\hat{S}_z\\), \\(s_z = \\pm 1/2\\) <code>nkstot</code> Given in the header, see above. <code>k_init</code>, <code>k_final</code> The k indices run from 1 to nkstot for colinear spin-unpolarized, noncolinear and SOC calculations. For spin-polarized calculations, the indices run from <code>1</code> to <code>nkstot</code> for spin up and <code>nkstot+1</code> to <code>2*nkstot</code> for spin down. <code>nbnd</code> Given in the header, see above. <code>overlap</code> \\(\\vert\\langle \\phi_{\\alpha}(\\boldsymbol{\\tau_i})\\vert \\psi_{n \\boldsymbol{k}}^\\sigma \\rangle\\vert^2\\) where \\(\\psi_{n \\boldsymbol{k}}^\\sigma\\) is the Bloch wave of band \\(n\\)=<code>band_i</code> with \\(k\\)=<code>kpts[k_i]</code> (possibly with spin \\(\\sigma\\)), and \\(\\phi_\\alpha(\\boldsymbol{\\tau}_i)\\) is an atomic-like wavefunction centered at \\(\\tau_i\\), the position of the atom with \\(i\\)=<code>atom_i</code>, and \\(\\alpha\\) is the appropriate set of quantum numbers depending on the type of calculation. <p>The orbitals are given by (from the <code>projwfc.x</code> input description): *  \\(l=1\\):</p> <code>m</code> Orbital Notes 1 \\(p_z\\) \\(m_l=0\\) 2 \\(p_x\\) real combination of \\(m_l\\)=+/-1 with cosine 3 \\(p_y\\) real combination of \\(m_l\\)=+/-1 with sine <ul> <li>\\(l=2\\):</li> </ul> <code>m</code> Orbital Notes 1 \\(d_{z^2}\\) \\(m_l=0\\) 2 \\(d_{zx}\\) real combination of \\(m_l=\\pm1\\) with cosine 3 \\(d_{zy}\\) real combination of \\(m_l=\\pm1\\) with sine 4 \\(d_{x^2-y^2}\\) real combination of \\(m_l=\\pm2\\) with cosine 5 \\(d_{xy}\\) real combination of \\(m=\\pm2\\) with sine * \\(l=3\\) (not implemented in <code>projwfc.x</code>)"},{"location":"dev_notes/projwfc_output_comparison/","title":"Comparison of <code>projwfc.x</code> output files","text":"<p>This document compares the output files of <code>projwfc.x</code> for the same calculation. The files are <code>projwfc.out</code> (just the <code>stdout</code> of <code>projwfc.x</code> redirected to a file), <code>filproj</code>, and <code>atomic_proj.xml</code>.</p> <code>projwfc.out</code> <code>filproj</code> <code>atomic_proj.xml</code> Structure \u274c \u2705 \u274c \\(k\\)-points\\(^\\text{[\\small{Note 1}]}\\) \u2705 \u274c \u2705 Eigenvalues \u2705 \u274c \u2705 \\(\\langle \\psi_{nk} \\vert \\phi \\rangle\\)\\(^{[\\small{\\text{Note 2}]}}\\) \u274c \u274c \u2705 \\(\\vert \\langle\\psi_{nk} \\vert \\phi\\rangle \\vert^2\\) \u2705\\(^{\\text{\\small{3 decimal places}}}\\) \u2705 \u2705\\(^\\text{\\small{from above}}\\) Principle quantum number \\(n\\) for \\(\\vert\\phi\\rangle\\)\\(^{\\small{[\\text{Note 3}]}}\\) \u274c \u2705 \u274c Orbital quantum numbers for \\(\\vert\\phi\\rangle\\)\\(^{\\small{[\\text{Note 3}]}}\\) \u2705 \u2705 \u274c Partial Parsing\\(^{\\small{[\\text{Note 4}]}}\\) \u274c \u274c \u2705 Same file for spin up/down\\(^{\\small{[\\text{Note 5}]}}\\) \u2705 \u274c \u2705 Overlaps \u2705 \u274c \u274c Lowdin Charges \u2705 \u274c \u274c \\(E_{\\text{Fermi}}\\) \u274c \u274c \u2705 Other Info\\(^{\\small{[\\text{Note 6}]}}\\) \u274c \u2705 \u274c <p>Note 1: the \\(k\\)-points in <code>projwfc.out</code> and <code>atomic_proj.xml</code> are in cartesian coordinates in units of <code>alat</code>, and there's no way to convert them without reading the header of <code>filproj</code> Note 2: It is necessary to know these if you want to obtain projections in the \\((l, m_l, s_z)\\) (or linear combinations thereof, e.g., \\(p_x\\) spin up orbitals) for calculations with SOC. Note 3: <code>projwfc.out</code> contains the quantum numbers (\\((l, m)\\) or \\((l,m,s_z)\\) or \\((l, j, m_j)\\)) of the atomic states in the header, so it's easy to extract them. It doesn't contain \\(n\\). They are spread throughout the file in <code>filproj</code> (which does contain \\(n\\), so you have to parse the entire file to extract them. They are absent from <code>atomic_proj.xml</code>, only a numerical index for the atomic state is present and must be matched against one of the other files. Note 4: You can extract only specific atomic states from <code>atomic_proj.xml</code> using an iterative XML parsing implementation. This can be a huge time save for large structures if you only care about certain orbitals (\\(O(10)\\) minutes vs seconds to parse). Note 5: For spin polarized calculations, you need <code>filproj.projwfc_up</code> and <code>filproj.projwfc_down</code>. However, <code>projwfc.out</code> in that case will include twice as many k-points, the first half of which is spin-up and the second half is spin-down, and it's not explicitly stated anywhere in the file that it's for a spin-polarized calculation (but you can tell because the Lowdin charges will mention spin up/down but the states won't have <code>s_z</code>) Note 6: <code>filproj</code> contains other information such as the number of valence electrons (useful), cutoffs and FFT grids (might be useful for working with Lowdin charges?).</p>"},{"location":"dev_notes/projwfc_output_comparison/#actual-data-in-the-files","title":"Actual Data in the Files","text":"<p>Comparing the projection data in <code>filproj</code> and <code>projwfc.out</code>, they are quite similar but in general filproj is better since it has more precision. I noticed they more or less agree to within 5e-3 for non-spin polarized, LSDA (spin down only), noncolinear and SOC calculations. For the case of LSDA (spin up), there are some discrepancies but they are not that large. I don't understand why. </p> <p>Another note from my code:</p> <pre><code>psi2 = float(band_dict[\"psi2\"])\npsi2_sum = np.sum(projections[:, k_i, band_i])\n# The precision is so low in projwfc.out\n# that they differ by 10-20%\nif not np.isclose(psi2, psi2_sum, atol=1e-1):\n     raise ValueError(\n     \"Sum of squared projections not \"             \"equal to |psi|^2 in projwfc.out \"           f\"file. {psi2} != {psi2_sum}\"\n     )\n</code></pre> <p>Note that the data in the XML is not symmetrized. Further, see this note about orthogonalization.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pymatgen<ul> <li>io<ul> <li>espresso<ul> <li>caffeinator</li> <li>inputs<ul> <li>base</li> <li>pwin</li> </ul> </li> <li>outputs<ul> <li>dos</li> <li>projwfc</li> <li>pwxml</li> </ul> </li> <li>utils</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/pymatgen/io/espresso/","title":"espresso","text":"<p>pymatgen-io-espresso is a pymatgen addon for parsing Quantum ESPRESSO files</p>"},{"location":"reference/pymatgen/io/espresso/caffeinator/","title":"caffeinator","text":"<p>Convert VASP inputs to PWSCF inputs.</p> Supported VASP inputs <p>KPOINTS* POSCAR</p> <p>Not (yet) supported:     INCAR     KPOINTS: generalized regular grids or              fully automatic (KSPACING) grids</p>"},{"location":"reference/pymatgen/io/espresso/caffeinator/#pymatgen.io.espresso.caffeinator.CaffeinationError","title":"<code>CaffeinationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for caffeination</p>"},{"location":"reference/pymatgen/io/espresso/caffeinator/#pymatgen.io.espresso.caffeinator.CaffeinationWarning","title":"<code>CaffeinationWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>Warning class for caffeination</p>"},{"location":"reference/pymatgen/io/espresso/caffeinator/#pymatgen.io.espresso.caffeinator.CartesianWarning","title":"<code>CartesianWarning(message)</code>","text":"<p>               Bases: <code>CaffeinationWarning</code></p> <p>Warning class for tpiba conversion</p> Source code in <code>pymatgen/io/espresso/caffeinator.py</code> <pre><code>def __init__(self, message):\n    self.message = message\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/utils/","title":"utils","text":"<p>Utility functions for parsing Quantum ESPRESSO input and output files</p>"},{"location":"reference/pymatgen/io/espresso/utils/#pymatgen.io.espresso.utils.FileGuesser","title":"<code>FileGuesser(filetype, xml_filename, prefix)</code>","text":"<p>Guesses a filename that matches the XML for a file of a specified filetype. This is done by combining the prefix from the XML with a set of extensions, as well as searching for some common file names, and searching in multiple directories near the XML file.</p> Filetype Extensions Set filenames Search Directories pwin <code>$prefix.in</code>, <code>$prefix.pwi</code> <code>bands.in</code>, <code>bands.pwi</code> <code>./</code>, <code>../</code> filproj <code>$prefix</code>, <code>$prefix.proj</code> <code>filproj</code> <code>./</code>, <code>dos/</code>, <code>pdos/</code>, <code>projwfc</code>, <code>../pdos/</code>, <code>../dos/</code>, <code>../projwfc/</code> fildos <code>$prefix.dos</code> <code>$prefix.pdos</code> <code>fildos</code>, <code>filpdos</code> <code>./</code>, <code>dos/</code>, <code>../pdos/</code>, <code>projwfc/</code>, <code>../dos/</code>, <code>../projwfc/</code> <p>Returns filename for pwin, and filproj/fildos/filpdos for the other types. This means that it will return, for example, <code>dos/$prefix.proj</code> instead of <code>dos/$prefix.proj.projwfc_up</code> for filproj, and <code>dos/$prefix.dos</code> instead of <code>dos/$prefix.dos.pdos_tot</code> for filpdos.</p>"},{"location":"reference/pymatgen/io/espresso/utils/#pymatgen.io.espresso.utils.FileGuesser--todo-include-outdir-in-the-guessing-game","title":"TODO: include <code>outdir</code> in the guessing game.","text":"PARAMETER DESCRIPTION <code>filetype</code> <p>The type of file to guess. Can be \"pwin\", \"filproj\", \"fildos\", or \"filpdos\".</p> <p> TYPE: <code>str</code> </p> <code>xml_filename</code> <p>The filename of the XML file to guess from.</p> <p> TYPE: <code>str</code> </p> <code>prefix</code> <p>The prefix of the XML file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pymatgen/io/espresso/utils.py</code> <pre><code>def __init__(self, filetype, xml_filename, prefix):\n    \"\"\"\n    Initializes the FileGuesser object with the filetype, XML filename, and prefix.\n\n    Arguments:\n        filetype (str): The type of file to guess. Can be \"pwin\", \"filproj\", \"fildos\", or \"filpdos\".\n        xml_filename (str): The filename of the XML file to guess from.\n        prefix (str): The prefix of the XML file.\n    \"\"\"\n    self.filetype = filetype\n    self.xml_filename = xml_filename\n    self.prefix = prefix\n\n    # Validate the filetype and set extensions, extras, and folders\n    self._validate_filetype()\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/utils/#pymatgen.io.espresso.utils.FileGuesser.guess","title":"<code>guess()</code>","text":"<p>Guesses the appropriate filename based on the filetype, XML filename, and prefix.</p> RETURNS DESCRIPTION <code>str</code> <p>The guessed filename that matches the specified filetype.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If no appropriate file is found.</p> Source code in <code>pymatgen/io/espresso/utils.py</code> <pre><code>def guess(self):\n    \"\"\"\n    Guesses the appropriate filename based on the filetype, XML filename, and prefix.\n\n    Returns:\n        str: The guessed filename that matches the specified filetype.\n\n    Raises:\n        FileNotFoundError: If no appropriate file is found.\n    \"\"\"\n    guesses = self._generate_guesses()\n    print(f\"All guesses for filetype = {self.filetype}\")\n    print(guesses)\n\n    # Filter guesses based on filetype-specific rules\n    if self.filetype == \"filpdos\":\n        guesses = [g for g in guesses if glob(f\"{g}.pdos_*\")]\n    elif self.filetype == \"filproj\":\n        guesses = [g for g in guesses if glob(f\"{g}.projwfc_*\")]\n    else:\n        guesses = [g for g in guesses if os.path.exists(g)]\n\n    if not guesses:\n        raise FileNotFoundError(\n            f\"All guesses for an appropriate {self.filetype} file don't exist.\"\n        )\n\n    if len(set(guesses)) &gt; 1:\n        warnings.warn(\n            f\"Multiple possible guesses for {self.filetype} found. Using the first one: {guesses[0]}\"\n        )\n\n    return guesses[0]\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/utils/#pymatgen.io.espresso.utils.IbravUntestedWarning","title":"<code>IbravUntestedWarning</code>","text":"<p>               Bases: <code>UserWarning</code></p> <p>Warning for untested ibrav values in ibrav_to_lattice and other related functions.</p>"},{"location":"reference/pymatgen/io/espresso/utils/#pymatgen.io.espresso.utils.parse_pwvals","title":"<code>parse_pwvals(val)</code>","text":"<p>Helper method to recursively parse values in the PWscf xml files. Supports array/list, dict, bool, float and int.</p> <p>Returns original string (or list of substrings) if no match is found.</p> Source code in <code>pymatgen/io/espresso/utils.py</code> <pre><code>def parse_pwvals(\n    val: str | dict | list | np.ndarray | None,\n) -&gt; str | dict[Any, Any] | list[Any] | np.ndarray | bool | float | int:\n    \"\"\"\n    Helper method to recursively parse values in the PWscf xml files. Supports array/list, dict, bool, float and int.\n\n    Returns original string (or list of substrings) if no match is found.\n    \"\"\"\n    # regex to match floats but not integers, including scientific notation\n    float_regex = r\"[+-]?(?=\\d*[.eE])(?=\\.?\\d)\\d*\\.?\\d*(?:[eE][+-]?\\d+)?\"\n    # regex to match just integers (signed or unsigned)\n    int_regex = r\"^(\\+|-)?\\d+$\"\n    if isinstance(val, dict):\n        val = {k: parse_pwvals(v) for k, v in val.items()}\n    elif isinstance(val, list):\n        val = [parse_pwvals(x) for x in val]\n    elif isinstance(val, np.ndarray):\n        val = [parse_pwvals(x) for x in val]\n        # Don't return as array unless all elements are same type\n        if all(isinstance(x, type(val[0])) for x in val):\n            val = np.array(val)\n    elif val is None:\n        val = None\n    elif not isinstance(val, str):\n        return val\n    elif \" \" in val:\n        val = [parse_pwvals(x) for x in val.split()]\n    elif val.lower() in (\"true\", \".true.\"):\n        val = True\n    elif val.lower() in (\"false\", \".false.\"):\n        val = False\n    elif re.fullmatch(float_regex, val):\n        val = float(val)\n    elif re.fullmatch(int_regex, val):\n        val = int(val)\n    return val\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/utils/#pymatgen.io.espresso.utils.ibrav_to_lattice","title":"<code>ibrav_to_lattice(ibrav, celldm)</code>","text":"<p>Convert ibrav and celldm to lattice parameters. Essentially a reimplementation of latgen.f90 See that module and the PW.x input documentation for more details.</p> PARAMETER DESCRIPTION <code>ibrav</code> <p>The ibrav value (see pw.x input documentation).</p> <p> TYPE: <code>int</code> </p> <code>celldm</code> <p>The celldm values (see pw.x input documentation).</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>Lattice</code> <p>The lattice corresponding to the ibrav and celldm values.</p> Source code in <code>pymatgen/io/espresso/utils.py</code> <pre><code>def ibrav_to_lattice(ibrav, celldm):\n    \"\"\"\n    Convert ibrav and celldm to lattice parameters.\n    Essentially a reimplementation of latgen.f90\n    See that module and the PW.x input documentation for more details.\n\n    Args:\n        ibrav (int): The ibrav value (see pw.x input documentation).\n        celldm (list): The celldm values (see pw.x input documentation).\n\n    Returns:\n        Lattice: The lattice corresponding to the ibrav and celldm values.\n    \"\"\"\n    warnings.warn(\n        \"ibrav != 0 has not been thoroughly tested. Please be careful.\",\n        IbravUntestedWarning,\n    )\n    _validate_celldm(ibrav, celldm)\n    a = celldm[0]\n    if ibrav == 0:\n        raise ValueError(\"ibrav = 0 requires explicit lattice vectors.\")\n    elif ibrav == 1:\n        # cubic P (sc)\n        a1 = [a, 0, 0]\n        a2 = [0, a, 0]\n        a3 = [0, 0, a]\n    elif ibrav == 2:\n        # cubic F (fcc)\n        a1 = [-a / 2, 0, a / 2]\n        a2 = [0, a / 2, a / 2]\n        a3 = [-a / 2, a / 2, 0]\n    elif ibrav == 3:\n        # cubic I (bcc)\n        a1 = [a / 2, a / 2, a / 2]\n        a2 = [-a / 2, a / 2, a / 2]\n        a3 = [-a / 2, -a / 2, a / 2]\n    elif ibrav == -3:\n        # cubic I (bcc), more symmetric axis:\n        a1 = [-a / 2, a / 2, a / 2]\n        a2 = [a / 2, -a / 2, a / 2]\n        a3 = [a / 2, a / 2, -a / 2]\n    elif ibrav == 4:\n        # Hexagonal and Trigonal P\n        c = celldm[2] * a\n        a1 = [a, 0, 0]\n        a2 = [-a / 2, a * np.sqrt(3) / 2, 0]\n        a3 = [0, 0, c]\n    elif ibrav == 5:\n        # Trigonal R, 3-fold axis c\n        # The crystallographic vectors form a three-fold star around\n        # the z-axis, the primitive cell is a simple rhombohedron.\n        cos_g = celldm[3]  # cos(gamma)\n        tx = np.sqrt((1 - cos_g) / 2)\n        ty = np.sqrt((1 - cos_g) / 6)\n        tz = np.sqrt((1 + 2 * cos_g) / 3)\n        a1 = [a * tx, -a * ty, a * tz]\n        a2 = [0, 2 * a * ty, a * tz]\n        a3 = [-a * tx, -a * ty, a * tz]\n    elif ibrav == -5:\n        # Trigonal R, 3-fold axis (111);\n        # The crystallographic vectors form a three-fold star around (111)\n        a_p = a / np.sqrt(3)  # a'\n        cos_g = celldm[3]  # cos(gamma)\n        tx = np.sqrt((1 - cos_g) / 2)\n        ty = np.sqrt((1 - cos_g) / 6)\n        tz = np.sqrt((1 + 2 * cos_g) / 3)\n        u = tz - 2 * np.sqrt(2) * ty\n        v = tz + np.sqrt(2) * ty\n        a1 = [a_p * u, a_p * v, a_p * v]\n        a2 = [a_p * v, a_p * u, a_p * v]\n        a3 = [a_p * v, a_p * v, a_p * u]\n    elif ibrav == 6:\n        # Tetragonal P (st)\n        c = celldm[2] * a\n        a1 = [a, 0, 0]\n        a2 = [0, a, 0]\n        a3 = [0, 0, c]\n    elif ibrav == 7:\n        # Tetragonal I (bct)\n        c = celldm[2] * a\n        a1 = [a / 2, -a / 2, c]\n        a2 = [a / 2, a / 2, c]\n        a3 = [-a / 2, -a / 2, c]\n    elif ibrav == 8:\n        # Orthorhombic P\n        b = celldm[1] * a\n        c = celldm[2] * a\n        a1 = [a, 0, 0]\n        a2 = [0, b, 0]\n        a3 = [0, 0, c]\n    elif ibrav == 9:\n        # Orthorhombic base-centered(bco)\n        b = celldm[1] * a\n        c = celldm[2] * a\n        a1 = [a / 2, b / 2, 0]\n        a2 = [-a / 2, b / 2, 0]\n        a3 = [0, 0, c]\n    elif ibrav == -9:\n        # Same as 9, alternate description\n        b = celldm[1] * a\n        c = celldm[2] * a\n        a1 = [a / 2, -b / 2, 0]\n        a2 = [a / 2, b / 2, 0]\n        a3 = [0, 0, c]\n    elif ibrav == 91:\n        # Orthorhombic one-face base-centered A-type\n        b = celldm[1] * a\n        c = celldm[2] * a\n        a1 = [a, 0, 0]\n        a2 = [0, b / 2, -c / 2]\n        a3 = [0, b / 2, c / 2]\n    elif ibrav == 10:\n        # Orthorhombic face-centered\n        b = celldm[1] * a\n        c = celldm[2] * a\n        a1 = [a / 2, 0, c / 2]\n        a2 = [a / 2, b / 2, 0]\n        a3 = [0, b / 2, c / 2]\n    elif ibrav == 11:\n        # Orthorhombic body-centered\n        b = celldm[1] * a\n        c = celldm[2] * a\n        a1 = [a / 2, b / 2, c / 2]\n        a2 = [-a / 2, b / 2, c / 2]\n        a3 = [-a / 2, -b / 2, c / 2]\n    elif ibrav == 12:\n        # Monoclinic P, unique axis c\n        b = celldm[1] * a\n        c = celldm[2] * a\n        cos_g = celldm[3]  # cos(gamma)\n        sin_g = math.sqrt(1 - cos_g**2)\n        a1 = [a, 0, 0]\n        a2 = [b * cos_g, b * sin_g, 0]\n        a3 = [0, 0, c]\n    elif ibrav == -12:\n        # Monoclinic P, unique axis b\n        b = celldm[1] * a\n        c = celldm[2] * a\n        cos_b = celldm[4]  # cos(beta)\n        sin_b = math.sqrt(1 - cos_b**2)  # sin(beta)\n        a1 = [a, 0, 0]\n        a2 = [0, b, 0]\n        a3 = [c * cos_b, 0, c * sin_b]\n    elif ibrav == 13:\n        # Monoclinic base-centered (unique axis c)\n        b = celldm[1] * a\n        c = celldm[2] * a\n        cos_g = celldm[3]  # cos(gamma)\n        sin_g = math.sqrt(1 - cos_g**2)  # sin(gamma)\n        a1 = [a / 2, 0, -c / 2]\n        a2 = [b * cos_g, b * sin_g, 0]\n        a3 = [a / 2, 0, c / 2]\n    elif ibrav == -13:\n        warnings.warn(\n            \"ibrav=-13 has a different definition in QE &lt; v.6.4.1.\\n\"\n            \"Please check the documentation. The new definition in QE &gt;= v.6.4.1 is \"\n            \"used by pymatgen.io.espresso.\\nThey are related by a1_old = -a2_new, \"\n            \"a2_old = a1_new, a3_old = a3_new.\"\n        )\n        b = celldm[1] * a\n        c = celldm[2] * a\n        cos_b = celldm[4]  # cos(beta)\n        sin_b = math.sqrt(1 - cos_b**2)  # sin(beta)\n        a1 = [a / 2, b / 2, 0]\n        a2 = [-a / 2, b / 2, 0]\n        a3 = [c * cos_b, 0, c * sin_b]\n    elif ibrav == 14:\n        # Triclinic\n        b = celldm[1] * a\n        c = celldm[2] * a\n        cos_g = celldm[3]  # cos(gamma)\n        sin_g = math.sqrt(1 - cos_g**2)  # sin(gamma)\n        cos_b = celldm[4]  # cos(beta)\n        cos_a = celldm[5]  # cos(alpha)\n        vol = np.sqrt(1 + 2 * cos_a * cos_b * cos_g - cos_a**2 - cos_b**2 - cos_g**2)\n\n        a1 = [a, 0, 0]\n        a2 = [b * cos_g, b * sin_g, 0]\n        a3 = [c * cos_b, c * (cos_a - cos_b * cos_g) / sin_g, c * vol / sin_g]\n    else:\n        raise ValueError(f\"Unknown ibrav: {ibrav}.\")\n\n    lattice_matrix = np.array([a1, a2, a3])\n    return Lattice(lattice_matrix)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/utils/#pymatgen.io.espresso.utils.projwfc_orbital_to_vasp","title":"<code>projwfc_orbital_to_vasp(l, m)</code>","text":"<p>Given l quantum number and \"m\" orbital index in projwfc output, convert to the orbital index in VASP (PROCAR).</p> orbital QE (m/l) VASP s 0/1 0 pz 1/1 2 px 1/2 3 py 1/3 1 dz2 2/1 6 dxz 2/2 7 dyz 2/3 5 dx2 2/4 8 dxy 2/5 4 Source code in <code>pymatgen/io/espresso/utils.py</code> <pre><code>def projwfc_orbital_to_vasp(l: int, m: int):  # noqa: E741\n    \"\"\"\n    Given l quantum number and \"m\" orbital index in projwfc output,\n    convert to the orbital index in VASP (PROCAR).\n\n    | orbital | QE (m/l) | VASP |\n    |---------|----------|------|\n    | s       | 0/1      |  0   |\n    | pz      | 1/1      |  2   |\n    | px      | 1/2      |  3   |\n    | py      | 1/3      |  1   |\n    | dz2     | 2/1      |  6   |\n    | dxz     | 2/2      |  7   |\n    | dyz     | 2/3      |  5   |\n    | dx2     | 2/4      |  8   |\n    | dxy     | 2/5      |  4   |\n\n    \"\"\"\n    if l &lt; 0 or l &gt; 2:\n        raise ValueError(f\"l must be 0, 1, or 2. Got {l}.\")\n    if m &lt; 1 or m &gt; 2 * l + 1:\n        raise ValueError(f\"m must be between 1 and 2*l+1. Got {m}.\")\n    l_map = [[0], [2, 3, 1], [6, 7, 5, 8, 4]]\n    return l_map[l][m - 1]\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/","title":"inputs","text":"<p>Package for Quantum ESPRESSO input files</p>"},{"location":"reference/pymatgen/io/espresso/inputs/base/","title":"base","text":"<p>This module defines the base input file classes.</p>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.CardOptions","title":"<code>CardOptions</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum type of all supported options for a PWin card.</p>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.CardOptions.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>:param s: String :return: SupportedOptions</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>@classmethod\ndef from_string(cls, s: str):\n    \"\"\"\n    :param s: String\n    :return: SupportedOptions\n    \"\"\"\n    for m in cls:\n        if m.value.lower() == s.lower():\n            return m\n    raise ValueError(f\"Can't interpret option {s}.\")\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.BaseInputFile","title":"<code>BaseInputFile(namelists, cards)</code>","text":"<p>               Bases: <code>ABC</code>, <code>MSONable</code></p> <p>Abstract Base class for input files</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, namelists: list[dict[str, Any]], cards: list[\"InputCard\"]):\n    namelist_names = [nml.value.name for nml in self.namelist_classes]\n    self.namelists = OrderedDict(\n        {name: namelists.get(name, None) for name in namelist_names}\n    )\n    card_names = [c.value.name for c in self.card_classes]\n    self.cards = OrderedDict({name: cards.get(name, None) for name in card_names})\n    property_names = namelist_names + card_names\n    for prop_name in property_names:\n        setattr(\n            self.__class__,\n            prop_name,\n            property(\n                self._make_getter(prop_name),\n                self._make_setter(prop_name),\n                self._make_deleter(prop_name),\n            ),\n        )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.BaseInputFile.namelist_classes","title":"<code>namelist_classes</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>All supported namelists as a SupportedInputs enum</p>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.BaseInputFile.card_classes","title":"<code>card_classes</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>All supported cards as a SupportedCards enum</p>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.BaseInputFile.from_file","title":"<code>from_file(filename)</code>  <code>classmethod</code>","text":"<p>Reads an inputfile from file</p> PARAMETER DESCRIPTION <code>filename</code> <p>path to file</p> <p> TYPE: <code>PathLike | str</code> </p> RETURNS DESCRIPTION <code>BaseInputFile</code> <p>PWin object</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: os.PathLike | str) -&gt; \"BaseInputFile\":\n    \"\"\"\n    Reads an inputfile from file\n\n    Args:\n        filename: path to file\n\n    Returns:\n        PWin object\n    \"\"\"\n    parser = f90nml.Parser()\n    parser.comment_tokens += \"#\"\n\n    pwi_str = pathlib.Path(filename).read_text()\n    namelists = {}\n    for k, v in parser.reads(pwi_str).items():\n        Namelist = cls.namelist_classes.from_string(k)\n        namelists[k] = Namelist(v)\n    cards = cls._parse_cards(pwi_str)\n\n    return cls(namelists, cards)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.BaseInputFile.validate","title":"<code>validate()</code>","text":"<p>Very basic validation for the input file. Currently only checks that required namelists and cards are present.</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"\n    Very basic validation for the input file.\n    Currently only checks that required namelists and cards are present.\n    \"\"\"\n    required_namelists = [\n        nml.value.name for nml in self.namelist_classes if nml.value.required\n    ]\n    if any(self.namelists[nml] is None for nml in required_namelists):\n        msg = \"Input file is missing required namelists:\"\n        for nml in required_namelists:\n            if self.namelists[nml] is None:\n                msg += f\" &amp;{nml.upper()}\"\n        warnings.warn(msg, EspressoInputWarning)\n        return False\n\n    required_cards = [c.value.name for c in self.card_classes if c.value.required]\n    if any(self.cards[card] is None for card in required_cards):\n        msg = \"Input file is missing required cards:\"\n        for card in required_cards:\n            if self.cards[card] is None:\n                msg += f\" {card.upper()}\"\n        warnings.warn(msg, EspressoInputWarning)\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.BaseInputFile.__str__","title":"<code>__str__()</code>","text":"<p>Return the input file as a string</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Return the input file as a string\n    \"\"\"\n    string = \"\"\n    for nml in self.namelists.values():\n        if nml is not None:\n            nml.indent = self._indent\n            string += str(nml) + \"\\n\"\n\n    for c in self.cards.values():\n        if c is not None:\n            c.indent = self._indent\n            string += str(c) + \"\\n\"\n\n    return string\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.BaseInputFile.to_file","title":"<code>to_file(filename, indent=2)</code>","text":"<p>Write the input file to a file.</p> PARAMETER DESCRIPTION <code>filename</code> <p>path to file</p> <p> TYPE: <code>PathLike | str</code> </p> <code>indent</code> <p>number of spaces to use for indentation</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def to_file(self, filename: os.PathLike | str, indent: int = 2):\n    \"\"\"\n    Write the input file to a file.\n\n    Args:\n        filename: path to file\n        indent: number of spaces to use for indentation\n    \"\"\"\n    self._indent = indent\n    with open(filename, \"wb\") as f:\n        f.write(self.__str__().encode(\"ascii\"))\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputNamelist","title":"<code>InputNamelist(*args, **kwargs)</code>","text":"<p>               Bases: <code>ABC</code>, <code>OrderedDict</code></p> <p>Abstract Base class for namelists in input files</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputNamelist.__str__","title":"<code>__str__()</code>","text":"<p>Convert namelist to string</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Convert namelist to string\n    \"\"\"\n    nl = f90nml.Namelist({self.name: self})\n    nl.indent = self.indent * \" \"\n    string = str(nl)\n    return re.sub(r\"^&amp;(\\w+)\", lambda m: m.group(0).upper(), string)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputCard","title":"<code>InputCard(option, body)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract Base class for cards in input files</p> PARAMETER DESCRIPTION <code>option</code> <p>The option for the card (e.g., \"RELAX\")</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>The body of the card</p> <p> TYPE: <code>list</code> </p> <pre><code>body (list): The body of the card\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, option: str | CardOptions, body: str):\n    \"\"\"\n    Args:\n        option (str): The option for the card (e.g., \"RELAX\")\n        body (list): The body of the card\n    \"\"\"\n    if isinstance(option, str):\n        option = self.opts.from_string(option)\n    self.option = option\n    self._body = body\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputCard.__str__","title":"<code>__str__()</code>","text":"<p>Convert card to string This implementation is for generic (i.e., not fully implemented) cards</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Convert card to string\n    This implementation is for generic (i.e., not fully implemented) cards\n    \"\"\"\n    return self.get_header() + self.get_body(\" \" * self.indent)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputCard.get_body","title":"<code>get_body(indent)</code>","text":"<p>Convert card body to string This implementation is for generic (i.e., not fully implemented) cards</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def get_body(self, indent: str) -&gt; str:\n    \"\"\"\n    Convert card body to string\n    This implementation is for generic (i.e., not fully implemented) cards\n    \"\"\"\n    return \"\".join(\n        f\"\\n{indent}{' '.join(line) if isinstance(line, list) else line}\"\n        for line in self._body\n    )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputCard.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>Create card object from string This implementation is for generic (i.e., not fully implemented) cards</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>@classmethod\ndef from_string(cls, s: str) -&gt; \"InputCard\":\n    \"\"\"\n    Create card object from string\n    This implementation is for generic (i.e., not fully implemented) cards\n    \"\"\"\n    option, body = cls.split_card_string(s)\n    return cls(option, body)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputCard.get_option","title":"<code>get_option(option)</code>  <code>classmethod</code>","text":"<p>Initializes a card's options</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>@classmethod\ndef get_option(cls, option: str) -&gt; CardOptions:\n    \"\"\"Initializes a card's options\"\"\"\n    if option is not None:\n        return cls.opts.from_string(option)\n    if cls.default_deprecated:\n        logging.warning(\n            f\"No option specified for {cls.name} card. This is deprecated, but {cls.default_option} will be used by default.\"\n        )\n    return cls.default_option\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputCard.split_card_string","title":"<code>split_card_string(s)</code>  <code>classmethod</code>","text":"<pre><code>    Splits a card into an option and a list of values of the correct type.\n    :param s: String containing a card (as it would appear in a PWin file)\n    :return: option: string for the card's option or None\n             values: list of lists of values for the card\n\n    Example:\n    &gt;&gt;&gt; s = \"ATOMIC_SPECIES\n</code></pre> <p>H 1.00794 H.UPF O 15.9994 O.UPF\"         &gt;&gt;&gt; option, values = InputCard.split_card_string_string(s)         &gt;&gt;&gt; option, values         &gt;&gt;&gt; (None, [[\"H\", 1.00794, \"H.UPF\"], [\"O\", 15.9994, \"O.UPF\"]])</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>@classmethod\ndef split_card_string(cls, s: str) -&gt; tuple[str, list]:\n    \"\"\"\n    Splits a card into an option and a list of values of the correct type.\n    :param s: String containing a card (as it would appear in a PWin file)\n    :return: option: string for the card's option or None\n             values: list of lists of values for the card\n\n    Example:\n    &gt;&gt;&gt; s = \"ATOMIC_SPECIES\\nH 1.00794 H.UPF\\nO 15.9994 O.UPF\"\n    &gt;&gt;&gt; option, values = InputCard.split_card_string_string(s)\n    &gt;&gt;&gt; option, values\n    &gt;&gt;&gt; (None, [[\"H\", 1.00794, \"H.UPF\"], [\"O\", 15.9994, \"O.UPF\"]])\n    \"\"\"\n    s = re.sub(r\"\\t\", \" \", s)\n    header = s.strip().split(\"\\n\")[0]\n    body = s.strip().split(\"\\n\")[1:]\n    if len(header.split()) &gt; 1:\n        option = re.sub(r\"[()]\", \"\", header.split()[1])\n        option = option.lower()\n        option = re.sub(r\"[()]\", \"\", option)\n        option = re.sub(r\"[{}]\", \"\", option)\n    else:\n        option = None\n    return cls.get_option(option), parse_pwvals(body)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.InputCard.get_header","title":"<code>get_header()</code>","text":"<p>Gets a card's header as a string</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def get_header(self) -&gt; str:\n    \"\"\"Gets a card's header as a string\"\"\"\n    if self.name is None:\n        return \"\"\n    header = f\"{self.name.upper()}\"\n    if self.option:\n        header += f\" {{{self.option}}}\"\n    return header\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.SupportedInputs","title":"<code>SupportedInputs</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum type of all supported input cards and namelists.</p>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.SupportedInputs.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>:param s: String :return: InputCard or InputNamelist</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>@classmethod\ndef from_string(cls, s: str):\n    \"\"\"\n    :param s: String\n    :return: InputCard or InputNamelist\n    \"\"\"\n    for m in cls:\n        if m.name.lower() == s.lower():\n            return m.value\n    raise ValueError(f\"Can't interpret card or namelist {s}.\")\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/base/#pymatgen.io.espresso.inputs.base.EspressoInputWarning","title":"<code>EspressoInputWarning</code>","text":"<p>               Bases: <code>UserWarning</code></p> <p>Warning class for PWin parsing.</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/","title":"pwin","text":"<p>Classes for reading/manipulating PWscf xml files.</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.ControlNamelist","title":"<code>ControlNamelist(*args, **kwargs)</code>","text":"<p>               Bases: <code>InputNamelist</code></p> <p>&amp;CONTROL namelist</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.SystemNamelist","title":"<code>SystemNamelist(*args, **kwargs)</code>","text":"<p>               Bases: <code>InputNamelist</code></p> <p>&amp;SYSTEM namelist</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.ElectronsNamelist","title":"<code>ElectronsNamelist(*args, **kwargs)</code>","text":"<p>               Bases: <code>InputNamelist</code></p> <p>&amp;ELECTRONS namelist</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.IonsNamelist","title":"<code>IonsNamelist(*args, **kwargs)</code>","text":"<p>               Bases: <code>InputNamelist</code></p> <p>&amp;IONS namelist</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.CellNamelist","title":"<code>CellNamelist(*args, **kwargs)</code>","text":"<p>               Bases: <code>InputNamelist</code></p> <p>&amp;CELL namelist</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.FcpNamelist","title":"<code>FcpNamelist(*args, **kwargs)</code>","text":"<p>               Bases: <code>InputNamelist</code></p> <p>&amp;FCP namelist</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.RismNamelist","title":"<code>RismNamelist(*args, **kwargs)</code>","text":"<p>               Bases: <code>InputNamelist</code></p> <p>&amp;RISM namelist</p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.AtomicSpeciesCard","title":"<code>AtomicSpeciesCard(option, symbols, masses, files)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>ATOMIC_SPECIES card</p> <pre><code>symbols: List of atomic symbols\nmasses: List of atomic masses\nfiles: List of pseudopotential file names\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>def __init__(\n    self,\n    option: str | CardOptions,\n    symbols: list[str],\n    masses: list[float],\n    files: list[str],\n):\n    \"\"\"\n    Args:\n        option: The option for the card\n        symbols: List of atomic symbols\n        masses: List of atomic masses\n        files: List of pseudopotential file names\n    \"\"\"\n    # TODO: cards that have no option shouldn't have an option parameter\n    # in the constructor\n    self.symbols = symbols\n    self.masses = masses\n    self.files = files\n    super().__init__(option, None)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.AtomicSpeciesCard.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>Parse a string containing an ATOMIC_SPECIES card</p> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>@classmethod\ndef from_string(cls, s: str):\n    \"\"\"Parse a string containing an ATOMIC_SPECIES card\"\"\"\n    option, body = cls.split_card_string(s)\n    symbols = [item[0] for item in body]\n    masses = [item[1] for item in body]\n    files = [item[2] for item in body]\n    return cls(option, symbols, masses, files)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.AtomicPositionsCard","title":"<code>AtomicPositionsCard(option, symbols, positions, force_multipliers)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>ATOMIC_POSITIONS card</p> <pre><code>symbols: List of atomic symbols\npositions: List of atomic positions\nforce_multipliers: List of force multipliers (0 or 1 for each atom's x, y, z coordinates. 0 means fixed, 1 means can move. See pw.x documentation for more details.)\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>def __init__(\n    self,\n    option: str | \"CardOptions\",\n    symbols: list[str],\n    positions: np.ndarray,\n    force_multipliers: np.ndarray,\n):\n    \"\"\"\n    Args:\n        option: The option for the card\n        symbols: List of atomic symbols\n        positions: List of atomic positions\n        force_multipliers: List of force multipliers (0 or 1 for each atom's x, y, z coordinates. 0 means fixed, 1 means can move. See pw.x documentation for more details.)\n    \"\"\"\n    self.option = option\n    self.symbols = symbols\n    assert len(symbols) == len(positions)\n    self.positions = positions\n    if force_multipliers is None:\n        force_multipliers = [[1, 1, 1] for _ in range(len(symbols))]\n    else:\n        assert len(force_multipliers) == len(symbols)\n    self.force_multipliers = force_multipliers\n    super().__init__(option, None)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.AtomicPositionsCard.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>Parse a string containing an ATOMIC_SPECIES card</p> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>@classmethod\ndef from_string(cls, s: str):\n    \"\"\"Parse a string containing an ATOMIC_SPECIES card\"\"\"\n    option, body = cls.split_card_string(s)\n\n    # Check if all lines of body have same length\n    if any(len(line) != len(body[0]) for line in body) or len(body[0]) not in [\n        4,\n        7,\n    ]:\n        print([len(line) for line in body])\n        raise PWinParserError(\n            \"All lines in ATOMIC_POSITIONS card must have the same number of columns, either 4 or 7\"\n        )\n    symbols = [line[0] for line in body]\n    positions = [np.array(line[1:4]) for line in body]\n    force_multipliers = [line[4:] for line in body] if len(body[0]) == 7 else None\n    if force_multipliers is not None and any(\n        any(f not in [0, 1] for f in fm) for fm in force_multipliers\n    ):\n        raise PWinParserError(\n            \"All force multipliers in ATOMIC_POSITIONS card must be either 0 or 1\"\n        )\n\n    return cls(option, symbols, positions, force_multipliers)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.KPointsCard","title":"<code>KPointsCard(option, grid, shift, k, weights, labels)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>K_POINTS card</p> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>def __init__(\n    self,\n    option: KPointsOptions | str,\n    grid: list,\n    shift: list,\n    k: list[list[float]] | np.ndarray,\n    weights: list[float] | np.ndarray,\n    labels: list[str],\n):\n    # TODO make labels a dict with index as key, much easier to work with\n    self.grid = grid\n    self.shift = shift\n    self.k = k\n    self.weights = weights\n    self.labels = labels\n    super().__init__(option, None)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.KPointsCard.line_mode","title":"<code>line_mode: bool</code>  <code>property</code>","text":"<p>Whether the k-points are in line mode</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.KPointsCard.band_mode","title":"<code>band_mode: bool</code>  <code>property</code>","text":"<p>Whether the k-points are in band mode</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.KPointsCard.coords_are_cartesian","title":"<code>coords_are_cartesian: bool</code>  <code>property</code>","text":"<p>Whether the k-points are in cartesian coordinates</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.KPointsCard.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>Parse a string containing K_POINTS card</p> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>@classmethod\ndef from_string(cls, s: str) -&gt; KPointsCard:\n    \"\"\"Parse a string containing K_POINTS card\"\"\"\n    option, body = cls.split_card_string(s)\n    grid, shift, k, weights, labels = [], [], [], [], []\n    if option == \"automatic\":\n        grid, shift = body[0][:3], [bool(s) for s in body[0][3:]]\n    elif option != \"gamma\":\n        for line in body[1:]:\n            k.append(line[:3])\n            weights.append(line[3])\n            labels.append(\n                \" \".join(line[4:]).strip(\"!\").lstrip() if len(line) &gt; 4 else \"\"\n            )\n\n    return cls(option, grid, shift, k, weights, labels)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.AdditionalKPointsCard","title":"<code>AdditionalKPointsCard(option, k, weights, labels)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>ADDITIONAL_K_POINTS card</p> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>def __init__(\n    self,\n    option: AdditionalKPointsOptions | str,\n    k: list[list[float]] | np.ndarray,\n    weights: list[float] | np.ndarray,\n    labels: list[str],\n):\n    # TODO make labels a dict with index as key, much easier to work with\n    self.k = k\n    self.weights = weights\n    self.labels = labels\n    super().__init__(option, None)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.AdditionalKPointsCard.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>Parse a string containing an ATOMIC_SPECIES card</p> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>@classmethod\ndef from_string(cls, s: str) -&gt; AdditionalKPointsCard:\n    \"\"\"Parse a string containing an ATOMIC_SPECIES card\"\"\"\n    option, body = cls.split_card_string(s)\n    k, weights, labels = [], [], []\n    for line in body[1:]:\n        k.append(line[:3])\n        weights.append(line[3])\n        labels.append(\n            \" \".join(line[4:]).strip(\"!\").lstrip() if len(line) &gt; 4 else \"\"\n        )\n\n    return cls(option, k, weights, labels)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.CellParametersCard","title":"<code>CellParametersCard(option, a1, a2, a3)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>CELL_PARAMETERS card</p> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>def __init__(\n    self,\n    option: CellParametersOptions,\n    a1: np.ndarray,\n    a2: np.ndarray,\n    a3: np.ndarray,\n):\n    self.a1, self.a2, self.a3 = a1, a2, a3\n    super().__init__(option, None)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.CellParametersCard.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>Parse a string containing an ATOMIC_SPECIES card</p> Source code in <code>pymatgen/io/espresso/inputs/pwin.py</code> <pre><code>@classmethod\ndef from_string(cls, s: str) -&gt; CellParametersCard:\n    \"\"\"Parse a string containing an ATOMIC_SPECIES card\"\"\"\n    option, body = cls.split_card_string(s)\n    a1, a2, a3 = map(lambda x: np.array(x, dtype=float), body)\n    return cls(option, a1, a2, a3)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.ConstraintsCard","title":"<code>ConstraintsCard(option, body)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>CONSTRAINTS card (not fully implemented)</p> <pre><code>body (list): The body of the card\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, option: str | CardOptions, body: str):\n    \"\"\"\n    Args:\n        option (str): The option for the card (e.g., \"RELAX\")\n        body (list): The body of the card\n    \"\"\"\n    if isinstance(option, str):\n        option = self.opts.from_string(option)\n    self.option = option\n    self._body = body\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.OccupationsCard","title":"<code>OccupationsCard(option, body)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>OCCUPATIONS card (not fully implemented)</p> <pre><code>body (list): The body of the card\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, option: str | CardOptions, body: str):\n    \"\"\"\n    Args:\n        option (str): The option for the card (e.g., \"RELAX\")\n        body (list): The body of the card\n    \"\"\"\n    if isinstance(option, str):\n        option = self.opts.from_string(option)\n    self.option = option\n    self._body = body\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.AtomicVelocitiesCard","title":"<code>AtomicVelocitiesCard(option, body)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>ATOMIC_VELOCITIES card (not fully implemented)</p> <pre><code>body (list): The body of the card\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, option: str | CardOptions, body: str):\n    \"\"\"\n    Args:\n        option (str): The option for the card (e.g., \"RELAX\")\n        body (list): The body of the card\n    \"\"\"\n    if isinstance(option, str):\n        option = self.opts.from_string(option)\n    self.option = option\n    self._body = body\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.AtomicForcesCard","title":"<code>AtomicForcesCard(option, body)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>ATOMIC_FORCES card (not fully implemented)</p> <pre><code>body (list): The body of the card\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, option: str | CardOptions, body: str):\n    \"\"\"\n    Args:\n        option (str): The option for the card (e.g., \"RELAX\")\n        body (list): The body of the card\n    \"\"\"\n    if isinstance(option, str):\n        option = self.opts.from_string(option)\n    self.option = option\n    self._body = body\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.SolventsCard","title":"<code>SolventsCard(option, body)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>SOLVENTS card (not fully implemented)</p> <pre><code>body (list): The body of the card\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, option: str | CardOptions, body: str):\n    \"\"\"\n    Args:\n        option (str): The option for the card (e.g., \"RELAX\")\n        body (list): The body of the card\n    \"\"\"\n    if isinstance(option, str):\n        option = self.opts.from_string(option)\n    self.option = option\n    self._body = body\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.HubbardCard","title":"<code>HubbardCard(option, body)</code>","text":"<p>               Bases: <code>InputCard</code></p> <p>HUBBARD card (not fully implemented)</p> <pre><code>body (list): The body of the card\n</code></pre> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, option: str | CardOptions, body: str):\n    \"\"\"\n    Args:\n        option (str): The option for the card (e.g., \"RELAX\")\n        body (list): The body of the card\n    \"\"\"\n    if isinstance(option, str):\n        option = self.opts.from_string(option)\n    self.option = option\n    self._body = body\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWin","title":"<code>PWin(namelists, cards)</code>","text":"<p>               Bases: <code>BaseInputFile</code></p> <p>Class for PWscf input files. Unlikely to be constructed directly, use the <code>from_file</code> method instead.</p> <p>The namelist attributes pretty much work like dictionaries, while the card attributes are all based on the InputCard class and its subclasses.</p> ATTRIBUTE DESCRIPTION <code>structure</code> <p>Structure object</p> <p> TYPE: <code>Structure</code> </p> <code>lattice</code> <p>Lattice object</p> <p> TYPE: <code>Lattice</code> </p> <code>alat</code> <p>alat (either celldm(1) or A) in ANGSTROM</p> <p> TYPE: <code>float</code> </p> <code>site_symbols</code> <p>List of site symbols in the input file</p> <p> TYPE: <code>list</code> </p> <code>celldm</code> <p>List of celldm parameters (6 elements, first is alat in ANGSTROM)</p> <p> TYPE: <code>list</code> </p> <code>atomic_species</code> <p>ATOMIC_SPECIES card</p> <p> TYPE: <code>AtomicSpeciesCard</code> </p> <code>atomic_positions</code> <p>ATOMIC_POSITIONS card</p> <p> TYPE: <code>AtomicPositionsCard</code> </p> <code>k_points</code> <p>K_POINTS card</p> <p> TYPE: <code>KPointsCard</code> </p> <code>additional_k_points</code> <p>ADDITIONAL_K_POINTS card</p> <p> TYPE: <code>AdditionalKPointsCard</code> </p> <code>cell_parameters</code> <p>CELL_PARAMETERS card</p> <p> TYPE: <code>CellParametersCard</code> </p> <code>constraints</code> <p>CONSTRAINTS card</p> <p> TYPE: <code>ConstraintsCard</code> </p> <code>occupations</code> <p>OCCUPATIONS card</p> <p> TYPE: <code>OccupationsCard</code> </p> <code>atomic_velocities</code> <p>ATOMIC_VELOCITIES card</p> <p> TYPE: <code>AtomicVelocitiesCard</code> </p> <code>atomic_forces</code> <p>ATOMIC_FORCES card</p> <p> TYPE: <code>AtomicForcesCard</code> </p> <code>solvents</code> <p>SOLVENTS card</p> <p> TYPE: <code>SolventsCard</code> </p> <code>hubbard</code> <p>HUBBARD card</p> <p> TYPE: <code>HubbardCard</code> </p> <code>control</code> <p>&amp;CONTROL namelist</p> <p> TYPE: <code>ControlNamelist</code> </p> <code>system</code> <p>&amp;SYSTEM namelist</p> <p> TYPE: <code>SystemNamelist</code> </p> <code>electrons</code> <p>&amp;ELECTRONS namelist</p> <p> TYPE: <code>ElectronsNamelist</code> </p> <code>ions</code> <p>&amp;IONS namelist</p> <p> TYPE: <code>IonsNamelist</code> </p> <code>cell</code> <p>&amp;CELL namelist</p> <p> TYPE: <code>CellNamelist</code> </p> <code>fcp</code> <p>&amp;FCP namelist</p> <p> TYPE: <code>FcpNamelist</code> </p> <code>rism</code> <p>&amp;RISM nam</p> <p> TYPE: <code>RismNamelist</code> </p> Source code in <code>pymatgen/io/espresso/inputs/base.py</code> <pre><code>def __init__(self, namelists: list[dict[str, Any]], cards: list[\"InputCard\"]):\n    namelist_names = [nml.value.name for nml in self.namelist_classes]\n    self.namelists = OrderedDict(\n        {name: namelists.get(name, None) for name in namelist_names}\n    )\n    card_names = [c.value.name for c in self.card_classes]\n    self.cards = OrderedDict({name: cards.get(name, None) for name in card_names})\n    property_names = namelist_names + card_names\n    for prop_name in property_names:\n        setattr(\n            self.__class__,\n            prop_name,\n            property(\n                self._make_getter(prop_name),\n                self._make_setter(prop_name),\n                self._make_deleter(prop_name),\n            ),\n        )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWin.site_symbols","title":"<code>site_symbols</code>  <code>property</code>","text":"<p>The list of site symbols in the input file (i.e., the atomic_species card)</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWin.structure","title":"<code>structure: Structure</code>  <code>property</code> <code>writable</code>","text":"RETURNS DESCRIPTION <code>Structure</code> <p>Structure object</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWin.lattice","title":"<code>lattice: Lattice</code>  <code>property</code> <code>writable</code>","text":"RETURNS DESCRIPTION <code>Lattice</code> <p>Lattice object (in ANGSTROM no matter what's in the input file)</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWin.alat","title":"<code>alat: float</code>  <code>property</code>","text":"<p>Returns alat (either celldm(1) or A) in ANGSTROM with proper error handling</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWin.celldm","title":"<code>celldm: list</code>  <code>property</code>","text":"<p>Gets celldm from the input file. If celldm is in the input file, returns it with the first element converted to angstrom and padded with zeros to length 6. If A is in the input instead, then it returns:     celldm = [A, B/A, C/A, cosBC, cosAC, cosAB] (with A in angstrom) with missing values padded to zeros</p> RETURNS DESCRIPTION <code>celldm</code> <p>list of celldm parameters, with shape (6,)</p> <p> TYPE: <code>list</code> </p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWin.PWinCards","title":"<code>PWinCards</code>","text":"<p>               Bases: <code>SupportedInputs</code></p> <p>Supported input cards for PWscf input files</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWin.PWinNamelists","title":"<code>PWinNamelists</code>","text":"<p>               Bases: <code>SupportedInputs</code></p> <p>Supported namelists for PWscf input files</p>"},{"location":"reference/pymatgen/io/espresso/inputs/pwin/#pymatgen.io.espresso.inputs.pwin.PWinParserError","title":"<code>PWinParserError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for PWin parsing.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/","title":"outputs","text":"<p>Package for Quantum ESPRESSO output files</p>"},{"location":"reference/pymatgen/io/espresso/outputs/dos/","title":"dos","text":"<p>Classes for reading/manipulating projwfc.x/dos.x (P)DOS files</p>"},{"location":"reference/pymatgen/io/espresso/outputs/dos/#pymatgen.io.espresso.outputs.dos.EspressoDos","title":"<code>EspressoDos(energies, tdos, idos=None, summed_pdos=None, summed_pdos_l=None, atomic_states=None, efermi=None, lsda=None, noncolinear=None, lspinorb=None)</code>","text":"<p>               Bases: <code>MSONable</code></p> <p>Class for representing DOS data from a dos.x or projwfc.x calculation</p> <p>unconventional. Use the class method constructors from_filpdos (to parse projwfc.x outputs) or from_fildos (to parse dos.x output) instead.</p> PARAMETER DESCRIPTION <code>energies</code> <p>Energies in eV. Not w.r.t the Fermi level.</p> <p> TYPE: <code>ndarray</code> </p> <code>tdos</code> <p>Total DOS.</p> <p> TYPE: <code>dict[Spin, ndarray]</code> </p> <code>idos</code> <p>Integrated DOS.</p> <p> TYPE: <code>dict[Spin, ndarray]</code> DEFAULT: <code>None</code> </p> <code>summed_pdos</code> <p>Summed PDOS across all states \\((l,m)\\) or \\((l,j, m_j)\\) etc. Should be the same as the total DOS but there might be minor rounding differences. This quantity is spin polarized in noncolinear calculations without SOC but tdos is not. This is essentially \\(\\sum_{l,m} \\mathrm{PDOS}_{l,m}\\) or \\(\\sum_{l,j,m_j} \\mathrm{PDOS}_{l,j,{m_j}}\\).</p> <p> TYPE: <code>dict[Spin, ndarray]</code> DEFAULT: <code>None</code> </p> <code>summed_pdos_l</code> <p>Summed pDOS for each orbital, pretty much just \\(\\sum_{m} \\mathrm{PDOS}_{l,m}\\) or \\(\\sum_{m_j} \\mathrm{PDOS}_{l,j,{m_j}}\\). Order is not guaranteed.</p> <p> TYPE: <code>dict[Spin, list[ndarray]]</code> DEFAULT: <code>None</code> </p> <code>atomic_states</code> <p>List of AtomicState objects. Order is guaranteed to be the same as projwfc.x output.</p> <p> TYPE: <code>list[AtomicState]</code> DEFAULT: <code>None</code> </p> <code>efermi</code> <p>Fermi energy. # TODO: beter default</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>lsda</code> <p>Whether the calculation is spin polarized. None indicates unknown.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> <code>noncolinear</code> <p>Whether the calculation is noncolinear (with or without SOC). None indicates unknown.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> <code>lspinorb</code> <p>Whether the calculation includes spin-orbit coupling. None indicates unknown.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> ATTRIBUTE DESCRIPTION <code>energies</code> <p>Energies in eV. Not w.r.t the Fermi level.</p> <p> TYPE: <code>ndarray</code> </p> <code>tdos</code> <p>Total DOS.</p> <p> TYPE: <code>dict[Spin, ndarray]</code> </p> <code>idos</code> <p>Integrated DOS.</p> <p> TYPE: <code>dict[Spin, ndarray]</code> </p> <code>atomic_states</code> <p>Ordered list of AtomicState objects.</p> <p> TYPE: <code>list[AtomicState]</code> </p> <code>efermi</code> <p>Fermi energy.</p> <p> TYPE: <code>float</code> </p> <code>lsda</code> <p>Whether the calculation is spin polarized.</p> <p> TYPE: <code>bool</code> </p> <code>noncolinear</code> <p>Whether the calculation is noncolinear.</p> <p> TYPE: <code>bool</code> </p> <code>lspinorb</code> <p>Whether the calculation includes spin-orbit coupling.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pymatgen/io/espresso/outputs/dos.py</code> <pre><code>def __init__(\n    self,\n    energies: np.ndarray,\n    tdos: dict[Spin, np.ndarray],\n    idos: dict[Spin, np.ndarray] = None,\n    summed_pdos: dict[Spin, np.ndarray] = None,\n    summed_pdos_l: dict[Spin, list[np.ndarray]] = None,\n    atomic_states: list[AtomicState] = None,\n    efermi: float | None = None,\n    lsda: bool | None = None,\n    noncolinear: bool | None = None,\n    lspinorb: bool | None = None,\n):\n    r\"\"\"\n    Initializes an Espresso Dos object from a list of energies and densities\n    of states. Shouldn't really be used directly unless you're doing something\n    unconventional. Use the class method constructors from_filpdos (to parse\n    projwfc.x outputs) or from_fildos (to parse dos.x output) instead.\n\n    Args:\n        energies (np.ndarray): Energies in eV. *Not* w.r.t the Fermi level.\n        tdos (dict[Spin, np.ndarray]): Total DOS.\n        idos (dict[Spin, np.ndarray], optional): Integrated DOS.\n        summed_pdos (dict[Spin, np.ndarray], optional): Summed PDOS across\n            all states $(l,m)$ or $(l,j, m_j)$ etc. Should be the same as the total DOS but there might be minor rounding differences. This quantity is spin\n            polarized in noncolinear calculations without SOC but tdos is not. This is essentially $\\sum_{l,m} \\mathrm{PDOS}_{l,m}$ or $\\sum_{l,j,m_j} \\mathrm{PDOS}_{l,j,{m_j}}$.\n        summed_pdos_l (dict[Spin, list[np.ndarray]], optional): Summed pDOS for each\n            orbital, pretty much just $\\sum_{m} \\mathrm{PDOS}_{l,m}$ or $\\sum_{m_j} \\mathrm{PDOS}_{l,j,{m_j}}$. Order is not guaranteed.\n        atomic_states (list[AtomicState], optional): List of AtomicState objects.\n            Order is guaranteed to be the same as projwfc.x output.\n        efermi (float, optional): Fermi energy. # TODO: beter default\n        lsda (bool, optional): Whether the calculation is spin polarized.\n            None indicates unknown.\n        noncolinear (bool, optional): Whether the calculation is noncolinear\n            (with or without SOC). None indicates unknown.\n        lspinorb (bool, optional): Whether the calculation includes spin-orbit\n            coupling. None indicates unknown.\n\n    Attributes:\n        energies (np.ndarray): Energies in eV. *Not* w.r.t the Fermi level.\n        tdos (dict[Spin, np.ndarray]): Total DOS.\n        idos (dict[Spin, np.ndarray]): Integrated DOS.\n        atomic_states (list[AtomicState]): Ordered list of AtomicState objects.\n        efermi (float): Fermi energy.\n        lsda (bool): Whether the calculation is spin polarized.\n        noncolinear (bool): Whether the calculation is noncolinear.\n        lspinorb (bool): Whether the calculation includes spin-orbit coupling.\n    \"\"\"\n\n    self.energies = energies\n    self.tdos = tdos\n    self.idos = idos\n    self.atomic_states = atomic_states  # Order guaranteed to be same as projwfc.x\n    self.efermi = efermi\n    self.noncolinear = noncolinear\n    self.lsda = lsda\n    self.lspinorb = lspinorb\n\n    # Shouldn't be exposed to the user\n    self._summed_pdos_l = summed_pdos_l  # Order is glob dependent\n    self._summed_pdos = summed_pdos\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/dos/#pymatgen.io.espresso.outputs.dos.EspressoDos.from_filpdos","title":"<code>from_filpdos(filpdos)</code>  <code>classmethod</code>","text":"<p>Initialize an EspressoDos object from projwfc.x pdos files. This requires the filproj.pdos_tot and all filproj.pdos_atm#_wfc# files to be present.</p> PARAMETER DESCRIPTION <code>filpdos</code> <p>path to the filproj pdos file. Note that this is the same quantity labeled \"filproj\" in projwfc.x's input, so it's not a full filename. For example, filpdos=\"path/to/filpdos\" will look for files like \"path/to/filpdos.pdos_atm#_wfc#...\".</p> <p> TYPE: <code>str | PathLike</code> </p> Source code in <code>pymatgen/io/espresso/outputs/dos.py</code> <pre><code>@classmethod\ndef from_filpdos(cls, filpdos: str | os.PathLike) -&gt; \"EspressoDos\":\n    \"\"\"\n    Initialize an EspressoDos object from projwfc.x pdos files. This requires\n    the filproj.pdos_tot and all filproj.pdos_atm#_wfc# files to be present.\n\n    Args:\n        filpdos (str | os.PathLike): path to the filproj pdos file. Note that this\n            is the same quantity labeled \"filproj\" in projwfc.x's input, so it's not a full filename. For example, filpdos=\"path/to/filpdos\" will look for files like \"path/to/filpdos.pdos_atm#_wfc#...\".\n    \"\"\"\n\n    # Read the total DOS first. This is the only way to distinguish between\n    # spin polarized calcs noncolinear calcs without SOC. We can't tell\n    # colinear non-spin-polarized and noncolinear-with-SOC apart yet.\n    E, tdos, summed_pdos, ncl_no_soc, lsda = cls._read_total_pdos(\n        f\"{filpdos}.pdos_tot\"\n    )\n    all_energies = [E]\n\n    atomic_states = []\n    summed_pdos_l = []\n    filenames = glob.glob(f\"{filpdos}.pdos_atm*\")\n    for f in filenames:\n        E, s_pdos_l, states = cls._read_pdos(f, ncl_no_soc)\n        atomic_states.extend(states)\n        summed_pdos_l.append(s_pdos_l)\n        all_energies.append(E)\n    if not np.allclose(all_energies, all_energies[0], rtol=0, atol=1e-4):\n        raise WrongDosFormatError(\"Energies from all files do not match.\")\n\n    energies = all_energies[0]\n    # Order the atomic states and compute the state #\n    atomic_states = cls._order_states(atomic_states)\n    lspinorb = atomic_states[0].j is not None\n    noncolinear = ncl_no_soc or lspinorb\n\n    return cls(\n        energies,\n        tdos,\n        summed_pdos_l=summed_pdos_l,\n        summed_pdos=summed_pdos,\n        atomic_states=atomic_states,\n        noncolinear=noncolinear,\n        lsda=lsda,\n        lspinorb=lspinorb,\n    )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/dos/#pymatgen.io.espresso.outputs.dos.EspressoDos.from_fildos","title":"<code>from_fildos(fildos)</code>  <code>classmethod</code>","text":"<p>Constructs a Dos object from a fildos (dos.x) file</p> <p>The format of Fildos is as follows (TDOS = total DOS, IDOS = integrated DOS):</p> <ul> <li> <p>Spin polarized:</p> <p>Energy(ev) TDOS(up) TODS(dn) IDOS</p> </li> <li> <p>Everything else:</p> <p>Energy(ev) TDOS IDOS</p> </li> </ul> PARAMETER DESCRIPTION <code>fildos</code> <p>path to the dos file. Same as the dos.x input.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pymatgen/io/espresso/outputs/dos.py</code> <pre><code>@classmethod\ndef from_fildos(cls, fildos: str | os.PathLike) -&gt; \"EspressoDos\":\n    \"\"\"\n    Constructs a Dos object from a fildos (dos.x) file\n\n    The format of Fildos is as follows (TDOS = total DOS, IDOS = integrated DOS):\n\n    * Spin polarized:\n\n        &gt; Energy(ev) TDOS(up) TODS(dn) IDOS\n\n    * Everything else:\n\n        &gt; Energy(ev) TDOS IDOS\n\n    Args:\n        fildos (str): path to the dos file. Same as the dos.x input.\n    \"\"\"\n    with open(fildos, \"r\") as f:\n        header = f.readline()\n        if match := re.match(r\".*?EFermi\\s*=\\s*(\\d+\\.\\d+)\\s*eV.*?\", header):\n            efermi = float(match[1])\n        else:\n            raise ValueError(\"Cannot find Fermi energy in the header.\")\n\n    lsda = False\n\n    data = np.loadtxt(fildos, skiprows=1)\n    energies = data[:, 0]\n    if (ncols := data.shape[1]) == 3:\n        # Colinear or noncolinear (with or without SOC)\n        tdos, idos = {Spin.up: data[:, 1]}, data[:, 2]\n    elif ncols == 4:\n        # spin polarized\n        lsda = True\n        tdos = {Spin.up: data[:, 1], Spin.down: data[:, 2]}\n        idos = data[:, 3]\n    else:\n        raise WrongDosFormatError(\n            f\"Unexpected number of columns {ncols} in {fildos}\"\n        )\n\n    return cls(energies, tdos, idos=idos, efermi=efermi, lsda=lsda)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/dos/#pymatgen.io.espresso.outputs.dos.WrongDosFormatError","title":"<code>WrongDosFormatError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the DOS file format is not recognized</p>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/","title":"projwfc","text":"<p>Classes for reading/manipulating Projwfc.x files.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.Projwfc","title":"<code>Projwfc(parameters, filename, proj_source, structure=None, atomic_states=None, k=None, k_weights=None, eigenvals=None)</code>","text":"<p>               Bases: <code>MSONable</code></p> <p>Class to parse projwfc.x output. Supports parsing from projwfc.out (projwfc.x's stdout), filproj, and atomic_proj.xml files. filproj is recommended for parsing, as it is the most complete source of data. See this page for a comparison of the three files.</p> ATTRIBUTE DESCRIPTION <code>parameters</code> <p>Parameters parsed from the header of the file. Contents depend on the source of the data.</p> <p> TYPE: <code>dict</code> </p> <code>structure</code> <p>Structure object parsed from the file.</p> <p> TYPE: <code>Structure</code> </p> <code>lspinorb</code> <p>Whether the calculation includes spin-orbit coupling.</p> <p> TYPE: <code>bool | None</code> </p> <code>noncolin</code> <p>Whether the calculation is noncolinear.</p> <p> TYPE: <code>bool | None</code> </p> <code>lsda</code> <p>Whether the calculation is spin-polarized.</p> <p> TYPE: <code>bool | None</code> </p> <code>nstates</code> <p>Number of atomic states parsed from the file.</p> <p> TYPE: <code>int</code> </p> <code>atomic_states</code> <p>List of AtomicState objects parsed from the file. Ordered in the same way projwfc.x orders them.</p> <p> TYPE: <code>list[AtomicState]</code> </p> <code>nk</code> <p>Number of k-points parsed from the file.</p> <p> TYPE: <code>int</code> </p> <code>nbands</code> <p>Number of bands parsed from the file.</p> <p> TYPE: <code>int</code> </p> <code>k</code> <p>k-points parsed from the file. Shape is (nkstot, 3).</p> <p> TYPE: <code>ndarray | None</code> </p> <code>k_weights</code> <p>k-point weights parsed from the file. Shape is (nkstot,).</p> <p> TYPE: <code>ndarray | None</code> </p> <code>eigenvals</code> <p>Eigenvalues parsed from the file. Shape is (nkstot, nbnd).</p> <p> TYPE: <code>ndarray | None</code> </p> <code>proj_source</code> <p>Source of the data. One of \"projwfc.out\", \"filproj\", or \"atomic_proj.xml\".</p> <p> TYPE: <code>str</code> </p> <p>A lot of arguments and parameters can be none since not all the files contain the same information. The parameters dictionary is parsed from the header of the file and can contain some or all of the following keys:</p> <ul> <li><code>natomwfc</code>: Number of atomic states</li> <li><code>nr1x, nr2x, nr3x</code>: Number of grid points on the coarse grid</li> <li><code>nr1, nr2, nr3</code>: Number of grid points on the fine grid</li> <li><code>gcutm</code>: plane wave cutoff as a g-vector</li> <li><code>dual</code>: ratio between charge density and plane wave cutoffs</li> <li><code>nkstot</code>: Number of k-points</li> <li><code>nbnd</code>: Number of bands</li> <li><code>nine</code>: Always the number 9</li> <li><code>lsda</code>: Whether the calculation is spin-polarized</li> <li><code>lspinorb</code>: Whether the calculation includes spin-orbit coupling</li> <li><code>noncolin</code>: Whether the calculation is noncolinear</li> </ul> PARAMETER DESCRIPTION <code>parameters</code> <p>Parameters parsed from the header of the file. Contents depend on the source of the data.</p> <p> TYPE: <code>dict</code> </p> <code>filename</code> <p>Path to the file</p> <p> TYPE: <code>str | PathLike</code> </p> <code>proj_source</code> <p>Source of the data. One of \"projwfc.out\", \"filproj\", or \"atomic_proj.xml\".</p> <p> TYPE: <code>str</code> </p> <code>structure</code> <p>Structure object parsed from the file.</p> <p> TYPE: <code>Structure</code> DEFAULT: <code>None</code> </p> <code>atomic_states</code> <p>List of AtomicState objects parsed from the file. Ordered in the same way projwfc.x orders them.</p> <p> TYPE: <code>list[AtomicState]</code> DEFAULT: <code>None</code> </p> <code>k</code> <p>k-points parsed from the file. Shape is (nkstot, 3).</p> <p> TYPE: <code>ndarray</code> DEFAULT: <code>None</code> </p> <code>k_weights</code> <p>k-point weights parsed from the file. Shape is (nkstot,).</p> <p> TYPE: <code>ndarray</code> DEFAULT: <code>None</code> </p> <code>eigenvals</code> <p>Eigenvalues parsed from the file. Shape is (nkstot, nbnd).</p> <p> TYPE: <code>ndarray</code> DEFAULT: <code>None</code> </p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>def __init__(\n    self,\n    parameters: dict[str, Any],\n    filename: str | os.PathLike,\n    proj_source: str,\n    structure: Structure | None = None,\n    atomic_states: list[\"AtomicState\"] | None = None,\n    k: np.ndarray[float] | None = None,\n    k_weights: np.ndarray[float] | None = None,\n    eigenvals: np.ndarray[float] | None = None,\n):\n    \"\"\"\n    Constructor for Projwfc object. Shouldn't really be used directly, use one of the class methods instead: `from_projwfcout`, `from_filproj`, or `from_xml`.\n\n    A lot of arguments and parameters can be none since not all the files contain\n    the same information. The parameters dictionary is parsed from the header of the\n    file and can contain some or all of the following keys:\n\n    - `natomwfc`: Number of atomic states\n    - `nr1x, nr2x, nr3x`: Number of grid points on the coarse grid\n    - `nr1, nr2, nr3`: Number of grid points on the fine grid\n    - `gcutm`: plane wave cutoff as a g-vector\n    - `dual`: ratio between charge density and plane wave cutoffs\n    - `nkstot`: Number of k-points\n    - `nbnd`: Number of bands\n    - `nine`: Always the number 9\n    - `lsda`: Whether the calculation is spin-polarized\n    - `lspinorb`: Whether the calculation includes spin-orbit coupling\n    - `noncolin`: Whether the calculation is noncolinear\n\n    Args:\n        parameters (dict): Parameters parsed from the header of the file.\n            Contents depend on the source of the data.\n        filename (str | os.PathLike): Path to the file\n        proj_source (str): Source of the data. One of \"projwfc.out\", \"filproj\",\n            or \"atomic_proj.xml\".\n        structure (Structure): Structure object parsed from the file.\n        atomic_states (list[AtomicState]): List of AtomicState objects parsed from\n            the file. Ordered in the same way projwfc.x orders them.\n        k (np.ndarray): k-points parsed from the file. Shape is (nkstot, 3).\n        k_weights (np.ndarray): k-point weights parsed from the file.\n            Shape is (nkstot,).\n        eigenvals (np.ndarray): Eigenvalues parsed from the file.\n            Shape is (nkstot, nbnd).\n    \"\"\"\n    self.parameters = parameters\n    self.structure = structure\n    self.lspinorb = parameters.get(\"lspinorb\")\n    self.noncolin = parameters.get(\"noncolin\")\n    self.lsda = parameters.get(\"lsda\")\n    self.nstates = parameters[\"natomwfc\"]\n    self.atomic_states = [] if atomic_states is None else atomic_states\n    self.nk = parameters[\"nkstot\"]\n    self.nbands = parameters[\"nbnd\"]\n    self.k = [] if k is None else k\n    self.k_weights = [] if k_weights is None else k_weights\n    self.eigenvals = {} if eigenvals is None else eigenvals\n    self.proj_source = proj_source\n    self._filename = filename\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.Projwfc.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality test. Meant for checking that the two objects come from the same calculation, not that they are identical. It also assumes that the atomic states are ordered identically, and it checks them against each other using the <code>AtomicState.__eq__</code> method (see that method for a description of how the comparison is done).</p> <p>This dunder method is really only intended as a check before adding two Projwfc objects together. See the <code>Projwfc.__add__</code> method for more information.</p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality test. Meant for checking that the two objects come from\n    the same calculation, not that they are identical. It also assumes that the atomic states are ordered identically, and it checks them against each other using the `AtomicState.__eq__` method (see that method for a description of how the comparison is done).\n\n    This dunder method is really only intended as a check before adding two Projwfc objects together. See the `Projwfc.__add__` method for more information.\n    \"\"\"\n    if not isinstance(other, Projwfc):\n        return False\n\n    # Not all sources of Projwfc data will have a structure\n    same_structure = (\n        self.structure == other.structure\n        if (self.structure and other.structure)\n        else True\n    )\n    same_states = all(\n        s1 == s2\n        for s1, s2 in zip(self.atomic_states, other.atomic_states, strict=False)\n    )\n    return all(\n        [\n            same_structure,\n            same_states,\n            self.lspinorb == other.lspinorb,\n            self.noncolin == other.noncolin,\n            self.nstates == other.nstates,\n            self.nk == other.nk,\n            self.nbands == other.nbands,\n        ]\n    )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.Projwfc.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine two Projwfc objects. This is intended for combining one object with the spin up channel and another with the spin down. This is only ever necessary when parsing filproj for a spin-polarized calculation, since the two channels are stored in separate files.</p> <p>Before addition, this method checks that the two objects must come from the same calculation see the <code>Projwfc.__eq__</code> method for more information. This check is guaranteed to pass if the two objects are parsed from two filproj files produced by the same calculation. Returns a new Projwfc object with the combined data.</p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>def __add__(self, other: \"Projwfc\"):\n    \"\"\"\n    Combine two Projwfc objects. This is intended for combining one object with the\n    spin up channel and another with the spin down. This is only ever necessary when\n    parsing filproj for a spin-polarized calculation, since the two channels are\n    stored in separate files.\n\n    Before addition, this method checks that the two objects must come from\n    the same calculation see the `Projwfc.__eq__` method for more information.\n    This check is guaranteed to pass if the two objects are parsed from two filproj\n    files produced by the same calculation. Returns a new Projwfc object with the\n    combined data.\n    \"\"\"\n    if not isinstance(other, Projwfc):\n        raise ValueError(\"Can only add Projwfc objects to other Projwfc objects.\")\n    if self != other:\n        raise InconsistentProjwfcDataError(\n            \"Can only add Projwfc objects from the same calculation.\"\n        )\n\n    # Check that one is spin up and the other is spin down\n    # Get all the spins of each object. These are the keys of the projection\n    # attribute.\n    spin1 = {\n        spin for state in self.atomic_states for spin in state.projections.keys()\n    }\n    spin2 = {\n        spin for state in other.atomic_states for spin in state.projections.keys()\n    }\n    if len(spin1) != 1 or len(spin2) != 1:\n        raise InconsistentProjwfcDataError(\n            (\n                \"You are trying to add two Projwfc objects with multiple spins. \"\n                \"This should only be used to add objects with one spin each.\"\n            )\n        )\n    spin1, spin2 = spin1.pop(), spin2.pop()\n    if spin1 == spin2:\n        raise InconsistentProjwfcDataError(\n            \"Can only add Projwfc objects with opposite spins.\"\n        )\n\n    result = deepcopy(self)\n    for s1, s2 in zip(result.atomic_states, other.atomic_states, strict=True):\n        s1.projections |= s2.projections\n\n    return result\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.Projwfc.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the object. This is intended to be a human-readable summary of the data parsed from the file. It includes the header information, a summary of the structure, and a summary of the atomic states. It also includes information about which data was parsed and which was not.</p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    String representation of the object. This is intended to be a human-readable\n    summary of the data parsed from the file. It includes the header information,\n    a summary of the structure, and a summary of the atomic states. It also\n    includes information about which data was parsed and which was not.\n    \"\"\"\n\n    # Incompletely parsed calculations (xml) won't have the noncolin or lspinorb\n    if self.noncolin is None:\n        header = \"Unknown \"\n    elif self.lspinorb:\n        header = \"Spin-orbit \"\n    elif self.noncolin:\n        header = \"Noncolinear \"\n    else:\n        header = \"Colinear \"\n    if self.lsda:\n        header += \"(spin-polarized) \"\n    header += f\"calculation with {self.nk} k-points and {self.nbands} bands.\"\n    out = [header, f\"Filename: {self._filename}\"]\n    k_parsed = f\"K-points parsed: {np.any(self.k)} \"\n    if np.any(self.k):\n        k_parsed += f\"(Units: {self.parameters['k_unit']})\"\n    out.extend(\n        (\n            k_parsed,\n            f\"K-point weights parsed: {np.any(self.k_weights)}\",\n            f\"Eigenvalues parsed: {bool(self.eigenvals)}\",\n            f\"Projections data source: {self.proj_source}\",\n            \"\\n------------ Structure ------------\",\n        )\n    )\n    if self.structure:\n        out.extend(str(self.structure).split(\"\\n\")[:5])\n        out.append(f\"Sites ({self.structure.num_sites})\")\n        # Almost identical to Structure.__str__\n        data = []\n        for site in self.structure.sites:\n            row = [\n                site.atom_i,\n                site.species_string,\n                *[f\"{j:0.6f}\" for j in site.frac_coords],\n                site.Z,\n            ]\n            data.append(row)\n        out.append(\n            tabulate(\n                data,\n                headers=[\"#\", \"SP\", \"a\", \"b\", \"c\", \"Z val.\"],\n            )\n        )\n    else:\n        out.append(\"Structure not parsed.\")\n    out.append(\"\\n---------- Atomic States ----------\")\n\n    if self.atomic_states and self.atomic_states[0].l is not None:\n        data = []\n        headers = [\"State #\", \"SP (#)\", \"Orbital\", \"l\"]\n        if self.lspinorb:\n            headers.extend([\"j\", \"mj\"])\n        elif self.noncolin:\n            headers.extend([\"m\", \"s_z\"])\n        else:\n            headers.extend([\"m\"])\n\n        for state in self.atomic_states:\n            _, orbital_str = state._to_projwfc_state_string()\n            orb = orbital_str.split()[1]\n            atom = state.site.species_string + \" (\" + str(state.site.atom_i) + \")\"\n            row = [state.state_i, atom, orb, state.l]\n            if state.j:\n                row.extend([state.j, state.mj])\n            elif state.s_z:\n                row.extend([state.m, state.s_z])\n            else:\n                row.extend([state.m])\n            data.append(row)\n\n        out.append(tabulate(data, headers=headers))\n    else:\n        out.append(\n            f\"Found {self.nstates} atomic states, but their type is unknown.\"\n        )\n\n    return \"\\n\".join(out)\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.Projwfc.from_projwfcout","title":"<code>from_projwfcout(filename, parse_projections=True)</code>  <code>classmethod</code>","text":"<p>Initialize from a projwfc.out file (stdout of projwfc.x)</p> PARAMETER DESCRIPTION <code>filename</code> <p>Path to the file</p> <p> TYPE: <code>str | PathLike</code> </p> <code>parse_projections</code> <p>Whether to parse the projections. If False, only the header of the file is parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>@classmethod\ndef from_projwfcout(\n    cls, filename: str | os.PathLike, parse_projections: bool = True\n):\n    \"\"\"\n    Initialize from a projwfc.out file (stdout of projwfc.x)\n\n    Args:\n        filename (str | os.PathLike): Path to the file\n        parse_projections (bool): Whether to parse the projections. If False, only\n            the header of the file is parsed.\n    \"\"\"\n\n    with open(filename, \"r\") as f:\n        if parse_projections:\n            data = f.read()\n        else:\n            # TODO: Does it matter how many lines you read if you don't parse\n            # the projections? Need benchmarking\n            nlines = 1000\n            head = list(itertools.islice(f, nlines))\n            data = \"\\n\".join(head)\n\n    parameters, atomic_states = cls._parse_projwfcout_header(data)\n    k, eigenvals = [], {}\n    if parse_projections:\n        k, eigenvals, atomic_states, projections = cls._parse_projwfcout_body(\n            data, parameters, atomic_states\n        )\n        parameters.update({\"k_unit\": \"2pi/alat\"})\n\n    return cls(\n        parameters,\n        filename,\n        proj_source=\"projwfc.out\" if parse_projections else None,\n        atomic_states=atomic_states,\n        k=k,\n        eigenvals=eigenvals,\n    )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.Projwfc.from_filproj","title":"<code>from_filproj(filename, parse_projections=True)</code>  <code>classmethod</code>","text":"<p>Construct a Projwfc object from a filproj file. This is the file generated by projwfc.x and is called <code>filproj.projwfc_up</code> by default.</p> <p>Spin-polarized calculations will also have a <code>filproj.projwfc_down</code> file. This method is intended to parse only one of the two files. If you want to parse both, you should parse them separately and then add them together as     <code>projwfc_total = projwfc_up + projwfc_down</code></p> <p>See the docstring of the <code>Projwfc.__add__</code> method for more information.</p> PARAMETER DESCRIPTION <code>filename</code> <p>Path to the file</p> <p> TYPE: <code>str</code> </p> <code>parse_projections</code> <p>Whether to parse the projections. If False, only the header of the file is read.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>@classmethod\ndef from_filproj(cls, filename: str | os.PathLike, parse_projections: bool = True):\n    \"\"\"\n    Construct a Projwfc object from a filproj file. This is the file\n    generated by projwfc.x and is called `filproj.projwfc_up` by default.\n\n    Spin-polarized calculations will also have a `filproj.projwfc_down` file. This method is intended to parse only one of the two files. If you want to parse both, you should parse them separately and then add them together as\n        `projwfc_total = projwfc_up + projwfc_down`\n\n    See the docstring of the `Projwfc.__add__` method for more information.\n\n    Args:\n        filename (str): Path to the file\n        parse_projections (bool): Whether to parse the projections.\n            If False, only the header of the file is read.\n    \"\"\"\n    parameters, structure, skip = cls._parse_filproj_header(filename)\n\n    nstates = parameters[\"natomwfc\"]\n    nkpnt = parameters[\"nkstot\"]\n    nbnd = parameters[\"nbnd\"]\n    noncolin = parameters[\"noncolin\"]\n    atomic_states = {}\n\n    if parse_projections:\n        # The length of an atomic state block in the filproj file\n        nlines = nbnd * nkpnt + 1\n\n        columns = np.arange(8) if noncolin else np.arange(7)\n        data = pd.read_csv(\n            filename,\n            skiprows=skip,\n            header=None,\n            sep=r'\\s+',\n            names=columns,\n            dtype=str,\n        )\n\n        orbital_headers = data.values[::nlines, :]\n        projections = data.values[:, 2]\n        projections = np.delete(projections, slice(None, None, nlines))\n        # k-point indices always run from 1 to nkpnt EXCEPT for the spin down\n        # channel in spin polarized calculations (in filproj.projwfc_down)\n        parameters[\"lsda\"] = int(data.values[1, 0]) == nkpnt + 1\n        spin = Spin.down if parameters[\"lsda\"] else Spin.up\n        projections = projections.reshape((nstates, nkpnt, nbnd), order=\"C\").astype(\n            float\n        )\n\n        # Process headers and save overlap data\n        atomic_states = [None] * nstates\n        for n in range(nstates):\n            state_parameters = cls._parse_filproj_state_header(\n                orbital_headers[n], parameters, structure\n            )\n            atomic_states[n] = AtomicState(\n                state_parameters, {spin: projections[n, :, :]}\n            )\n\n    return cls(\n        parameters,\n        filename,\n        proj_source=\"filproj\" if parse_projections else None,\n        atomic_states=atomic_states,\n        structure=structure,\n    )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.Projwfc.from_xml","title":"<code>from_xml(filename, parse_eigenvals=True, parse_k=True, parse_projections=True, selection=None, store_phi_psi=False)</code>  <code>classmethod</code>","text":"<p>Constructs a Projwfc object from an atomic_proj.xml file. This uses a selective parsing method, where only the data requested is parsed. This is useful for large files where only a subset of the data is needed. However, please note that projwfc XML files are not symmetrized. Please see this page for a comparison of the three files and some important details.</p> PARAMETER DESCRIPTION <code>filename</code> <p>Path to the file</p> <p> TYPE: <code>str | PathLike</code> </p> <code>parse_eigenvals</code> <p>Whether to parse the eigenvalues</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>parse_k</code> <p>Whether to parse the k-points</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>parse_projections</code> <p>Whether to parse the projections. Note that the XML does not actually contain the projections, but \\(\\langle \\phi | \\psi \\rangle\\) where \\(\\phi\\) is the local orbital and \\(\\psi\\) is the Bloch function. The projections are computed as \\(|\\langle \\phi | \\psi\\rangle|^2\\).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>selection</code> <p>List of atomic states to parse. If None, all states are parsed. One indexed list (just like projwfc.x's ouptut)</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>store_phi_psi</code> <p>Whether to store the raw data in the AtomicState objects. This will increase memory usage.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>@classmethod\ndef from_xml(\n    cls,\n    filename: str | os.PathLike,\n    parse_eigenvals: bool = True,\n    parse_k: bool = True,\n    parse_projections: bool = True,\n    selection: list[int] | bool = None,\n    store_phi_psi: bool = False,\n):\n    r\"\"\"\n    Constructs a Projwfc object from an atomic_proj.xml file. This uses a selective parsing method, where only the data requested is parsed. This is useful for large files where only a subset of the data is needed. However, please note that projwfc XML files are *not* symmetrized. Please see [this page](../../../../../dev_notes/projwfc_output_comparison.md) for a comparison of the three files and some important details.\n\n    Args:\n        filename (str | os.PathLike): Path to the file\n        parse_eigenvals (bool): Whether to parse the eigenvalues\n        parse_k (bool): Whether to parse the k-points\n        parse_projections (bool): Whether to parse the projections. Note that the\n            XML does not actually contain the projections, but\n            $\\langle \\phi | \\psi \\rangle$ where $\\phi$ is the local orbital\n            and $\\psi$ is the Bloch function. The projections are computed as\n            $|\\langle \\phi | \\psi\\rangle|^2$.\n        selection (list): List of atomic states to parse. If None, all states\n            are parsed. One indexed list (just like projwfc.x's ouptut)\n        store_phi_psi (bool): Whether to store the raw data in the AtomicState\n            objects. This will increase memory usage.\n    \"\"\"\n    projections, phi_psi, eigenvals, k, weights, parameters = (\n        cls._iterative_xml_parse(\n            filename,\n            parse_eigenvals,\n            parse_k,\n            parse_projections,\n            selection,\n            store_phi_psi,\n        )\n    )\n\n    lsda = parameters[\"lsda\"]\n    natomwfc = parameters[\"natomwfc\"]\n    if selection is None:\n        selection = np.arange(1, natomwfc + 1)\n\n    # Create empty AtomicState objects for everything, only fill in parsed ones\n    atomic_states = [AtomicState({\"state_i\": i + 1}) for i in np.arange(natomwfc)]\n    if parse_projections:\n        for state_i in selection - 1:\n            state = atomic_states[state_i]\n            state.projections[Spin.up] = projections[0, :, state_i, :]\n            if lsda:\n                state.projections[Spin.down] = projections[1, :, state_i, :]\n            if store_phi_psi:\n                state.phi_psi[Spin.up] = phi_psi[0, :, state_i, :]\n                if lsda:\n                    state.phi_psi[Spin.down] = phi_psi[1, :, state_i, :]\n\n    proj_source = \"atomic_proj.xml\" if parse_projections else None\n    return cls(\n        parameters,\n        filename,\n        proj_source,\n        atomic_states=atomic_states,\n        k=k,\n        k_weights=weights,\n        eigenvals=eigenvals,\n    )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.AtomicState","title":"<code>AtomicState(parameters, projections=None, phi_psi=None, pdos=None, energies=None)</code>","text":"<p>               Bases: <code>MSONable</code></p> <p>Class to store information about a single atomic state from projwfc.x or dox.x</p> <p>An atomic state is defined as an orbital one specific atom. The orbital is:     - Defined by (n, l, m) if the calculation is colinear and not spin-polarized     - Defined by (n, l, m) if the calculation is colinear spin-polarized. In this         case, the spin up and spin down states are included in the same object.     - Defined by (n, l, j, s_z) if the calculation is noncolinear without SOC.     - Defined by (n, l, j, mj) if the calculation is noncolinear with SOC.</p> <p>Where:</p> <ul> <li>n is the principal quantum number</li> <li>l is the orbital or angular quantum number</li> <li>m is the magnetic quantum number</li> <li>j is the total angular momentum quantum number</li> <li>m_j is the magnetic quantum number of the total angular momentum</li> <li>s_z is the z component of the local spin (+- 1/2)</li> </ul> <p>QE also uses the notation of \"wfc\" to index the wavefunctions coming from a specific atom's pseudopotential. So these are unique l's or unique (l, j) pairs.</p> ATTRIBUTE DESCRIPTION <code>state_i</code> <p>Index of this state, as indexed by projwfc.x</p> <p> TYPE: <code>int</code> </p> <code>wfc_i</code> <p>Index of the wavefunction in the calculation</p> <p> TYPE: <code>int</code> </p> <code>l</code> <p>Orbital angular momentum quantum number</p> <p> TYPE: <code>int</code> </p> <code>j</code> <p>Total angular momentum quantum number</p> <p> TYPE: <code>float</code> </p> <code>mj</code> <p>Magnetic quantum number of the total angular momentum</p> <p> TYPE: <code>float</code> </p> <code>s_z</code> <p>S_z projection on a local z-axis (NCL calcs without SOC)</p> <p> TYPE: <code>float</code> </p> <code>m</code> <p>Magnetic quantum number</p> <p> TYPE: <code>int</code> </p> <code>n</code> <p>Principal quantum number</p> <p> TYPE: <code>int</code> </p> <code>site</code> <p>Site object for the atom</p> <p> TYPE: <code>PeriodicSite</code> </p> <code>orbital</code> <p>Orbital object</p> <p> TYPE: <code>Orbital</code> </p> <code>projections</code> <p>Projections of the state onto the atomic orbitals</p> <p> TYPE: <code>dict</code> </p> <code>phi_psi</code> <p>Overlap of the state with the wavefunction</p> <p> TYPE: <code>dict</code> </p> <code>pdos</code> <p>Projected density of states of the state</p> <p> TYPE: <code>dict</code> </p> <code>energies</code> <p>Energies for the PDOS</p> <p> TYPE: <code>ndarray</code> </p> PARAMETER DESCRIPTION <code>parameters</code> <p>Dictionary with the following keys</p> <ul> <li><code>state_i</code> (int): Index of this state, as indexed by projwfc.x</li> <li><code>wfc_i</code> (int): Index of the wavefunction in the pseudopotential</li> <li><code>l</code> (int): Orbital angular momentum quantum number</li> <li><code>j</code> (float): Total angular momentum quantum number</li> <li><code>mj</code> (float): Magnetic quantum number of the total angular momentum</li> <li><code>s_z</code> (float): S_z projection on a local z-axis (NCL calcs without SOC)</li> <li><code>m</code> (int): Magnetic quantum number</li> <li><code>n</code> (int): Principal quantum number</li> <li><code>site</code> (Site): Site object for the atom</li> </ul> <p> TYPE: <code>dict</code> </p> <code>projections</code> <p>Projections from every band and k-point onto this atomic orbital.</p> <p> TYPE: <code>dict[Spin, ndarray]</code> DEFAULT: <code>None</code> </p> <code>phi_psi</code> <p>Overlaps</p> <p> TYPE: <code>dict[Spin, ndarray]</code> DEFAULT: <code>None</code> </p> <code>pdos</code> <p>Projected density of states</p> <p> TYPE: <code>dict[Spin, ndarray]</code> DEFAULT: <code>None</code> </p> <code>orbital</code> <p>(pymatgen.electronic_structure.core.Orbital): Orbital object Undefined for calculations with SOC.</p> <p> </p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>def __init__(\n    self,\n    parameters: dict[str, Any],\n    projections: dict[Spin, np.ndarray] = None,\n    phi_psi: dict[Spin, np.ndarray] = None,\n    pdos: dict[Spin, np.ndarray] = None,\n    energies: np.ndarray = None,\n):\n    \"\"\"\n    Initialize an AtomicState object.\n\n    Args:\n        parameters (dict): Dictionary with the following keys\n\n            - `state_i` (int): Index of this state, as indexed by projwfc.x\n            - `wfc_i` (int): Index of the wavefunction in the pseudopotential\n            - `l` (int): Orbital angular momentum quantum number\n            - `j` (float): Total angular momentum quantum number\n            - `mj` (float): Magnetic quantum number of the total angular momentum\n            - `s_z` (float): S_z projection on a local z-axis (NCL calcs without SOC)\n            - `m` (int): Magnetic quantum number\n            - `n` (int): Principal quantum number\n            - `site` (Site): Site object for the atom\n\n        projections (dict[Spin, np.ndarray]): Projections from every band and\n            k-point onto this atomic orbital.\n        phi_psi (dict[Spin, np.ndarray]): Overlaps\n        pdos (dict[Spin, np.ndarray]): Projected density of states\n        orbital: (pymatgen.electronic_structure.core.Orbital): Orbital object\n            Undefined for calculations with SOC.\n    \"\"\"\n    self.state_i = parameters.get(\"state_i\")\n    self.wfc_i = parameters.get(\"wfc_i\")\n    self.l = parameters.get(\"l\")\n    self.j = parameters.get(\"j\")\n    self.mj = parameters.get(\"mj\")\n    self.s_z = parameters.get(\"s_z\")\n    self.m = parameters.get(\"m\")\n    self.n = parameters.get(\"n\")\n    self.site = parameters.get(\"site\")\n    self.orbital = None\n    if self.l is not None and self.m is not None:\n        self.orbital = Orbital(projwfc_orbital_to_vasp(self.l, self.m))\n    self.projections = {} if projections is None else projections\n    self.phi_psi = {} if phi_psi is None else phi_psi\n    self.pdos = pdos\n    self.energies = energies\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.AtomicState.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality test. This tests that the two objects represent the same state, i.e., same quantum numbers, state index, etc.</p> Source code in <code>pymatgen/io/espresso/outputs/projwfc.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality test. This tests that the two objects represent the same state,\n    i.e., same quantum numbers, state index, etc.\n    \"\"\"\n    if not isinstance(other, AtomicState):\n        return False\n\n    return all(\n        [\n            self.state_i == other.state_i,\n            self.wfc_i == other.wfc_i,\n            self.l == other.l,\n            self.j == other.j,\n            self.mj == other.mj,\n            self.s_z == other.s_z,\n            self.m == other.m,\n            self.n == other.n,\n            self.site == other.site,\n            self.orbital == other.orbital,\n        ]\n    )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.ProjwfcParserError","title":"<code>ProjwfcParserError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for Projwfc parsing.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/projwfc/#pymatgen.io.espresso.outputs.projwfc.InconsistentProjwfcDataError","title":"<code>InconsistentProjwfcDataError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for Projwfc addition.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/","title":"pwxml","text":"<p>Classes for reading/manipulating PWscf xml files.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml","title":"<code>PWxml(filename, ionic_step_skip=1, ionic_step_offset=0, parse_dos=False, fildos=None, parse_pdos=False, filpdos=None, parse_projected_eigen=False, filproj=None, occu_tol=1e-08, separate_spins=False, **_)</code>","text":"<p>               Bases: <code>Vasprun</code></p> <p>Parser for PWscf xml files. Almost all Vasprun features are implemented. This class exposes a public API that is practically identical to the Vasprun class, with values always returned in the same coordinate and unit systems used by VASP. Can be used interchangeably with Vasprun for most purposes with no changes to the calling code. This class will pull data from the output of <code>projwfc.x</code> and <code>dos.x</code> when necessary, attempting to guess the filenames if they are not provided.</p> <p>Some attributes are not particularly meaningful for QE, and a few are not implemented.</p> <p>Missing Vasprun features:</p> <ul> <li>Projected magnetization. Not sure we can get this from QE (maybe <code>pp.x</code>?).     <code>bands.x</code> supports computing \\(\\langle \\sigma_\\alpha \\rangle\\), but not     projected.</li> <li>Phononic properties: Need to write parser for <code>ph.x</code> output for dynamical matrix,     interatomic force constants, phonon frequencies, and eigenvectors.</li> <li>Dielectric properties: None of these are implemented. Some can be obtained from   <code>ph.x</code> or QE's old <code>epsilon.x</code>. Some are RPA and thus not available in QE.</li> </ul> <p>Not all attributes are listed below since many are inherited directly from Vasprun.</p> ATTRIBUTE DESCRIPTION <code>kpoints_frac</code> <p>kpoints in fractional coordinates, (nk, 3) array</p> <p> TYPE: <code>ndarray</code> </p> <code>kpoints_cart</code> <p>kpoints in cartesian coords (1/angst), (nk, 3) array</p> <p> TYPE: <code>ndarray</code> </p> <code>actual_kpoints</code> <p>Same as kpoints_frac, maintained for compatibility with Vasprun.</p> <p> TYPE: <code>ndarray</code> </p> <code>actual_kpoints_weights</code> <p>List of kpoint weights, normalized.</p> <p> TYPE: <code>ndarray</code> </p> <code>atomic_symbols</code> <p>List of atomic symbols, e.g., [\"Li\", \"Fe\", \"Fe\", \"P\", \"P\", \"P\"].</p> <p> TYPE: <code>list[str]</code> </p> <code>efermi</code> <p>Fermi energy, eV.</p> <p> TYPE: <code>float</code> </p> <code>vbm</code> <p>Valence band maximum, as computed by QE, in eV.</p> <p> TYPE: <code>float</code> </p> <code>cbm</code> <p>Conduction band minimum, as computed by QE, in eV.</p> <p> TYPE: <code>float</code> </p> <code>eigenvalues</code> <p>Final eigenvalues (in eV) as a dict with keys Spin.up/Spin.down, and the values are numpy arrays with dimensions (nk, nb, 2), where nk is the number of kpoints, nb is the number of bands, and the last axis is the eigenvalue and occupation. Identical representation to Vasprun.</p> <p> TYPE: <code>dict[Spin, ndarray]</code> </p> <code>projected_eigenvalues</code> <p>Final projected eigenvalues as a dict of {spin: nd-array}. To access a particular value, you need to index as <code>[spin][kpoint index][band index][atom index][orbital_index]</code>. This representation is identical to Vasprun.xml.</p> <p> TYPE: <code>dict[Spin, ndarray]</code> </p> <code>tdos</code> <p>Total dos from fildos or filpdos. filpdos overrides fildos.</p> <p> TYPE: <code>Dos</code> </p> <code>idos</code> <p>Integrated dos from fildos.</p> <p> TYPE: <code>Dos</code> </p> <code>pdos</code> <p>List of Dos objects, indexed as <code>[atom][orbital][spin]</code>.</p> <p> TYPE: <code>[List[dict[Orbital, Dict[spin, ndarray]]]]</code> </p> <code>ionic_steps</code> <p>All ionic steps, list of</p> <p>{ \"structure\": structure at end of run, \"total_energy\": {\"ehart\", \"etxc\", ...} \"stress\": pressure in eV/A3, \"forces\": forces in eV/A }.</p> <p> TYPE: <code>list[dict]</code> </p> <code>nionic_steps</code> <p>The total number of ionic steps. This number is always equal to the total number of steps in the actual run even if ionic_step_skip is used. nionic_steps here has a slightly different meaning from the Vasprun class. VASP will first do an SCF calculation with the input structure, then perform geometry optimization until you hit EDIFFG or NSW, then it's done. QE does the same thing for relax, but it will also do a final SCF calculation with the optimized structure and a new basis set for vc-relax. In reality, converged QE vc-relax calculations take nionic_steps-1 to converge.</p> <p> TYPE: <code>int</code> </p> <code>projected_magnetisation</code> <p>Not implemented</p> <p> TYPE: <code>dict[Spin, ndarray]</code> </p> <code>other_dielectric</code> <p>Not implemented</p> <p> TYPE: <code>dict</code> </p> <code>force_constants</code> <p>Not implemented.</p> <p> TYPE: <code>ndarray</code> </p> <code>normalmode_eigenvals</code> <p>Not implemented.</p> <p> TYPE: <code>ndarray</code> </p> <code>normalmode_eigenvecs</code> <p>Not implemented.</p> <p> TYPE: <code>ndarray</code> </p> <code>md_data</code> <p>Molecular dynamics data, not implemented for QE.</p> <p> TYPE: <code>dict</code> </p> <code>parameters</code> <p>Parameters of the PWscf run from the XML.  Naturally very different from Vasprun.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>incar</code> <p>Empty Incar object, for compatibility.</p> <p> TYPE: <code>Incar</code> </p> <code>kpoints</code> <p>Empty Kpoints object, for compatibility.</p> <p> TYPE: <code>Kpoints</code> </p> <code>pseudo_filenames</code> <p>List of pseudopotential filenames, e.g., [\"Li.pbe-spn-kjpaw_psl.0.1.UPF\", \"Fe.pbe-n-kjpaw_psl.0.2.1.UPF\", ...].</p> <p> TYPE: <code>list[str]</code> </p> <code>potcar_symbols</code> <p>Maintained for compatibility with Vasprun, has Psuedo + element names, e.g., ['Si.pbesol-n-rrkjus_psl.1.0.0.UPF Si'].</p> <p> TYPE: <code>list[str]</code> </p> <p>Author: Omar A. Ashour</p> PARAMETER DESCRIPTION <code>filename</code> <p>Path to XML file to parse</p> <p> TYPE: <code>str | PathLike</code> </p> <code>ionic_step_skip</code> <p>If ionic_step_skip is a number &gt; 1, only every ionic_step_skip ionic steps will be read for structure and energies. Unlike Vasprun, the final energy will always be the total energy of the scf calculation performed after ionic convergence. This is not very useful since PWscf xml files aren't as huge as Vasprun files. Mainly kept for consistency with the Vasprun class.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>ionic_step_offset</code> <p>Used together with ionic_step_skip. If set, the first ionic step read will be offset by the amount of ionic_step_offset. For example, if you want to start reading every 10th structure but only from the 3rd structure onwards, set ionic_step_skip to 10 and ionic_step_offset to 3. Main use case is when doing statistical structure analysis with extremely long time scale PWscf calculations of varying numbers of steps, and kept for consistency with the Vasprun class.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>parse_dos</code> <p>Whether to parse the dos. If True, PWxml will use fildos if provided, or attempt to guess the filename.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>fildos</code> <p>If provided, forces parse_dos to be True and uses the provided string as the path to the dos file. This is the same as in dos.x input, and shouldn't be a full path to a file. For example, filpdos=\"path/to/filpdos\" will look for \"path/to/filpdos.pdos_*\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>filpdos</code> <p>If provided, forces parse_dos to be True and uses  the provided string as 'filproj', same as in projwfc.x input.  It shouldn't include the rest of the filename. For example,  filpdos=\"path/to/filpdos\" will look for \"path/to/filpdos.pdos_*\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>parse_projected_eigen</code> <p>Whether to parse the projected eigenvalues and (magnetisation, not implemented). Defaults to False. If True, PWxml will look for a \"filproj\" from projwfc.x and parse it. It will look for files with the same name as the XML (or same QE prefix) but with a .projwfc_up extension, or will use the filproj argument</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>filproj</code> <p>If provided, forces parse_projected_eigen to be True and uses the provided string as the filepath to the .projwfc_up file. Note that this is the same as in projwfc.x input, so it shouldn't include the .projwfc_up/down extension. It can also include a directory, e.g., \"path/to/filproj\" will look for \"path/to/filproj.projwfc_up\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>occu_tol</code> <p>Sets the minimum tol for the determination of the vbm and cbm. Usually the default of 1e-8 works well enough, but there may be pathological cases. Note that, unlike VASP, QE actually reports the VBM and CBM (accessible via the vbm and cbm attributes), so this is only used to recompute them and check against the reported values.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>separate_spins</code> <p>Whether the band gap, CBM, and VBM should be reported for each individual spin channel. Defaults to False, which computes the eigenvalue band properties independent of the spin orientation. If True, the calculation must be spin-polarized.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pymatgen/io/espresso/outputs/pwxml.py</code> <pre><code>def __init__(\n    self,\n    filename: str | os.PathLike,\n    ionic_step_skip: int = 1,\n    ionic_step_offset: int = 0,\n    parse_dos: bool = False,\n    fildos: str | os.PathLike | None = None,\n    parse_pdos: bool = False,\n    filpdos: str | os.PathLike | None = None,\n    parse_projected_eigen: bool = False,\n    filproj: str | os.PathLike | None = None,\n    occu_tol: float = 1e-8,\n    separate_spins: bool = False,\n    **_,  # Ignored arguments for compatibility with Vasprun\n):\n    \"\"\"\n    Constructor for the PWxml class.\n\n    Args:\n        filename (str | os.PathLike): Path to XML file to parse\n        ionic_step_skip (int): If ionic_step_skip is a number &gt; 1,\n            only every ionic_step_skip ionic steps will be read for\n            structure and energies. Unlike Vasprun, the final energy\n            will always be the total energy of the scf calculation\n            performed after ionic convergence. This is not very useful\n            since PWscf xml files aren't as huge as Vasprun files.\n            Mainly kept for consistency with the Vasprun class.\n        ionic_step_offset (int): Used together with ionic_step_skip. If set,\n            the first ionic step read will be offset by the amount of\n            ionic_step_offset. For example, if you want to start reading\n            every 10th structure but only from the 3rd structure onwards,\n            set ionic_step_skip to 10 and ionic_step_offset to 3. Main use\n            case is when doing statistical structure analysis with\n            extremely long time scale PWscf calculations of\n            varying numbers of steps, and kept for consistency with the\n            Vasprun class.\n        parse_dos (bool): Whether to parse the dos. If True, PWxml will use\n            fildos if provided, or attempt to guess the filename.\n        fildos (str): If provided, forces parse_dos to be True and uses the\n            provided string as the path to the dos file. This is\n            the same as in dos.x input, and shouldn't be a full path to a file.\n            For example, filpdos=\"path/to/filpdos\" will look for\n            \"path/to/filpdos.pdos_*\"\n        filpdos (str): If provided, forces parse_dos to be True and uses\n             the provided string as 'filproj', same as in projwfc.x input.\n             It shouldn't include the rest of the filename. For example,\n             filpdos=\"path/to/filpdos\" will look for \"path/to/filpdos.pdos_*\"\n        parse_projected_eigen (bool): Whether to parse the projected\n            eigenvalues and (magnetisation, not implemented). Defaults to False.\n            If True, PWxml will look for a \"filproj\" from projwfc.x and parse it.\n            It will look for files with the same name as the XML (or same QE prefix)\n            but with a .projwfc_up extension, or will use the filproj argument\n        filproj (str): If provided, forces parse_projected_eigen to be True and\n            uses the provided string as the filepath to the .projwfc_up file.\n            Note that this is the same as in projwfc.x input, so it shouldn't\n            include the .projwfc_up/down extension. It can also include\n            a directory, e.g., \"path/to/filproj\" will look for\n            \"path/to/filproj.projwfc_up\"\n        occu_tol (float): Sets the minimum tol for the determination of the\n            vbm and cbm. Usually the default of 1e-8 works well enough,\n            but there may be pathological cases. Note that, unlike VASP, QE\n            actually reports the VBM and CBM (accessible via the vbm and cbm\n            attributes), so this is only used to recompute them\n            and check against the reported values.\n        separate_spins (bool): Whether the band gap, CBM, and VBM should be\n            reported for each individual spin channel. Defaults to False,\n            which computes the eigenvalue band properties independent of\n            the spin orientation. If True, the calculation must be spin-polarized.\n    \"\"\"\n    self._filename = filename\n    self.ionic_step_skip = ionic_step_skip\n    self.ionic_step_offset = ionic_step_offset\n    self.occu_tol = occu_tol\n    self.separate_spins = separate_spins\n\n    if filproj:\n        parse_projected_eigen = True\n    if fildos:\n        parse_dos = True\n    if filpdos:\n        parse_pdos = True\n\n    with zopen(filename, \"rt\") as f:\n        self._parse(\n            f,\n            parse_dos=parse_dos,\n            fildos=fildos,\n            parse_pdos=parse_pdos,\n            filpdos=filpdos,\n            parse_projected_eigen=parse_projected_eigen,\n            filproj=filproj,\n            ionic_step_skip=ionic_step_skip,\n            ionic_step_offset=ionic_step_offset,\n        )\n\n    if not self.converged:\n        warnings.warn(\n            (\n                f\"{filename} is an unconverged PWscf run.\\n\"\n                f\"Electronic convergence reached: {self.converged_electronic}.\\n\"\n                f\"Ionic convergence reached: {self.converged_ionic}.\"\n            ),\n            UnconvergedPWxmlWarning,\n        )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.is_spin","title":"<code>is_spin: bool</code>  <code>property</code>","text":"RETURNS DESCRIPTION <code>bool</code> <p>True if the calculation is spin-polarized.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.converged_electronic","title":"<code>converged_electronic: bool</code>  <code>property</code>","text":"<p>Returns true if electronic convergence was reached in the last ionic step. Note that, even though QE internally considers NSCF calculations unconverged, this property is set to True for NSCF (and bands) calcs to maintain consistency with the Vasprun class.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if electronic step convergence has been reached in the final</p> <code>bool</code> <p>ionic step</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.converged_ionic","title":"<code>converged_ionic: bool</code>  <code>property</code>","text":"RETURNS DESCRIPTION <code>bool</code> <p>True if ionic step convergence has been reached</p> <p>To maintain consistency with the Vasprun class, we return True if the calculation didn't involve geometric optimization (scf, nscf, ...)</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.final_energy","title":"<code>final_energy: float</code>  <code>property</code>","text":"<p>Final energy from the PWscf run, in eV.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.hubbards","title":"<code>hubbards: dict[str, float]</code>  <code>property</code>","text":"<p>Hubbard U values used if a vasprun is a GGA+U run. {} otherwise.</p> RETURNS DESCRIPTION <code>dict</code> <p>{element: U_value}</p> <p> TYPE: <code>dict[str, float]</code> </p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.run_type","title":"<code>run_type</code>  <code>property</code>","text":"<p>Returns the run type.</p> <p>Should be able to detect functional, Hubbard U terms and vdW corrections.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.eigenvalue_band_properties","title":"<code>eigenvalue_band_properties: tuple[float, float, float, bool] | tuple[tuple[float, float], tuple[float, float], tuple[float, float], tuple[bool, bool]]</code>  <code>property</code>","text":"<p>Returns the band gap, CBM, VBM, and whether the gap is direct. Directly uses the Vasprun implementation, with some extra check against the CBM and VBM values reported by QE.</p> RETURNS DESCRIPTION <code>tuple[float, float, float, bool] | tuple[tuple[float, float], tuple[float, float], tuple[float, float], tuple[bool, bool]]</code> <p>If separate_spins is False, returns a tuple of the band gap, CBM, VBM, and whether the gap is direct. If separate_spins is True, returns a tuple of tuples of the band gap, CBM, VBM, and whether the gap is direct for each spin channel.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.projected_eigenvalues","title":"<code>projected_eigenvalues: dict[Spin, np.ndarray] | None</code>  <code>property</code>","text":"<p>Returns the projected eigenvalues in the same format Vasprun uses (i.e., the VASP convention)</p> <p>In the case of SOC, QE uses the |LJJz&gt; basis while VASP uses the |LLz&gt; basis. This function will sum all p states into where py should be (index 1) and all d states into where dxy should be (index 4). The rest will be 0.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.projected_eigenvalues--todo-cleanup-and-rewrite","title":"TODO: cleanup and rewrite","text":""},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.projected_magnetisation","title":"<code>projected_magnetisation</code>  <code>property</code>","text":"<p>Returns the projected magnetisation for each atom in a format compatible with the Vasprun class. Not currently implemented for QE.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.md_data","title":"<code>md_data</code>  <code>property</code>","text":"<p>Molecular dynamics data. Not currently implemented for QE.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.epsilon_static","title":"<code>epsilon_static: list[float]</code>  <code>property</code>","text":"<p>The static part of the dielectric constant. Not implemented for QE.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.epsilon_static_wolfe","title":"<code>epsilon_static_wolfe: list[float]</code>  <code>property</code>","text":"<p>The static part of the dielectric constant without any local field effects. Not implemented for QE.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.epsilon_ionic","title":"<code>epsilon_ionic: list[float]</code>  <code>property</code>","text":"<p>The ionic part of the static dielectric constant. Not implemented for QE.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.dielectric","title":"<code>dielectric: tuple[list, list, list]</code>  <code>property</code>","text":"<p>The real and imaginary part of the dielectric constant (e.g., computed by RPA) in function of the energy (frequency). Optical properties (e.g. absorption coefficient) can be obtained through this.</p> <p>Not implemented for QE.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.optical_absorption_coeff","title":"<code>optical_absorption_coeff: list[float] | None</code>  <code>property</code>","text":"<p>The optical absorption coefficient from the dielectric constants. Not implemented for QE.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.get_band_structure","title":"<code>get_band_structure(kpoints_filename=None, efermi='smart', line_mode=False, force_hybrid_mode=False)</code>","text":"<p>Get the band structure as a BandStructure object.</p> PARAMETER DESCRIPTION <code>kpoints_filename</code> <p>Path of the PWscf input file from which the band structure is generated. If none is provided, the code will try to guess the appropriate file, see the docstring of <code>FileGuesser</code>.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>efermi</code> <p>The Fermi energy associated with the bandstructure, in eV. By default (None), uses the value reported by PWscf in the xml. To manually set the Fermi energy, pass a float. Pass 'smart' to use the <code>calculate_efermi()</code> method, which is identical for metals but more accurate for insulators (mid-gap).</p> <p> TYPE: <code>float | Literal['smart'] | None</code> DEFAULT: <code>'smart'</code> </p> <code>line_mode</code> <p>Force the band structure to be considered as a run along symmetry lines. (Default: False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_hybrid_mode</code> <p>Not Yet Implemented (Default: False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>BandStructureSymmLine | BandStructure</code> <p>a BandStructure object (or more specifically a BandStructureSymmLine object if the run is detected to be a run along symmetry lines) NSCF (calc='nscf' or 'bands') calculations are accepted for Line-Mode with explicit PWscf input file, and 'crystal', 'crystal_b', 'tpiba' or 'tpiba_b' K_POINTS card. The k-points needs to have data on the kpoint label as a comment.</p> Source code in <code>pymatgen/io/espresso/outputs/pwxml.py</code> <pre><code>def get_band_structure(\n    self,\n    kpoints_filename: str | None = None,\n    efermi: float | Literal[\"smart\"] | None = \"smart\",\n    line_mode: bool = False,\n    force_hybrid_mode: bool = False,\n) -&gt; BandStructureSymmLine | BandStructure:\n    \"\"\"Get the band structure as a BandStructure object.\n\n    Args:\n        kpoints_filename: Path of the PWscf input file from which the band\n            structure is generated. If none is provided, the code will try to\n            guess the appropriate file, see the docstring of `FileGuesser`.\n        efermi: The Fermi energy associated with the bandstructure, in eV. By\n            default (None), uses the value reported by PWscf in the xml. To\n            manually set the Fermi energy, pass a float. Pass 'smart' to use the\n            `calculate_efermi()` method, which is identical for metals but more\n            accurate for insulators (mid-gap).\n        line_mode: Force the band structure to be considered as\n            a run along symmetry lines. (Default: False)\n        force_hybrid_mode: Not Yet Implemented (Default: False)\n\n    Returns:\n        a BandStructure object (or more specifically a\n            BandStructureSymmLine object if the run is detected to be a run\n            along symmetry lines) NSCF (calc='nscf' or 'bands') calculations are accepted for Line-Mode with explicit PWscf input file, and 'crystal', 'crystal_b', 'tpiba' or 'tpiba_b' K_POINTS card. The k-points needs to have data on the kpoint label as a comment.\n    \"\"\"\n    factor = 1 if self.noncolin else 2\n    if self.nbands &lt;= self.nelec / factor:\n        warnings.warn(\n            f\"Number of bands ({self.nbands}) &lt;= number of electrons/{factor} \"\n            f\"({self.nelec / factor:.4f}). BSPlotter may not work properly.\",\n            DifferentFromVASPWarning,\n        )\n\n    if not kpoints_filename:\n        kpoints_filename = FileGuesser(\"pwin\", self._filename, self.prefix).guess()\n\n    if kpoints_filename and not os.path.exists(kpoints_filename) and line_mode:\n        raise PWxmlParserError(\n            \"PW input file needed to obtain band structure along symmetry lines.\"\n        )\n\n    if efermi == \"smart\":\n        e_fermi = self.calculate_efermi()\n    elif efermi is None:\n        e_fermi = self.efermi\n    else:\n        e_fermi = efermi\n\n    lattice_new = Lattice(self.final_structure.lattice.reciprocal_lattice.matrix)\n\n    p_eigenvals: defaultdict[Spin, list] = defaultdict(list)\n    eigenvals: defaultdict[Spin, list] = defaultdict(list)\n\n    for spin, v in self.eigenvalues.items():\n        v = np.swapaxes(v, 0, 1)\n        eigenvals[spin] = v[:, :, 0]\n\n        if self.projected_eigenvalues:\n            peigen = self.projected_eigenvalues[spin]\n            # Original axes for self.projected_eigenvalues are kpoints,\n            # band, ion, orb.\n            # For BS input, we need band, kpoints, orb, ion.\n            peigen = np.swapaxes(peigen, 0, 1)  # Swap kpoint and band axes\n            peigen = np.swapaxes(peigen, 2, 3)  # Swap ion and orb axes\n\n            p_eigenvals[spin] = peigen\n\n    k_card = None\n    if kpoints_filename and os.path.exists(kpoints_filename):\n        k_card = PWin.from_file(kpoints_filename).k_points\n    coords_are_cartesian = False if k_card is None else k_card.coords_are_cartesian\n    if coords_are_cartesian:\n        kpoints = [np.array(kpt) for kpt in self.kpoints_cart]\n    else:\n        kpoints = [np.array(kpt) for kpt in self.kpoints_frac]\n\n    if k_card.line_mode or line_mode:\n        labels_dict = {}\n        # TODO: check how hybrid band structs work in QE\n        hybrid_band = False\n        if hybrid_band or force_hybrid_mode:\n            raise NotImplementedError(\n                \"Hybrid band structures not yet supported in line mode.\"\n            )\n        kpoints, eigenvals, p_eigenvals, labels_dict = self._vaspify_kpts_bands(\n            kpoints, eigenvals, p_eigenvals, k_card, self.alat\n        )\n        return BandStructureSymmLine(\n            kpoints,\n            eigenvals,\n            lattice_new,\n            e_fermi,\n            labels_dict,\n            structure=self.final_structure,\n            projections=p_eigenvals,\n            coords_are_cartesian=coords_are_cartesian,\n        )\n    return BandStructure(\n        kpoints,\n        eigenvals,\n        lattice_new,\n        e_fermi,\n        structure=self.final_structure,\n        projections=p_eigenvals,\n        coords_are_cartesian=coords_are_cartesian,\n    )\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxml.calculate_efermi","title":"<code>calculate_efermi(**_)</code>","text":"<p>Calculate the Fermi level</p> <p>PWscf returns the Fermi level for all calculations and the cbm and vbm for all insulators. These are stored in PWxml.efermi, PWxml.cbm, and PWxml.vbm. However, for insulators, the Fermi level is often slightly off from the exact mid-gap value.</p> <p>If vbm and cbm are both undefined (metallic system), return the Fermi level if vbm is defined and cbm isn't, it's usually a sign of an insulator with as many bands as electrons (often nbnd isn't set in input) Such calculations don't work with BSPlotter()</p> RETURNS DESCRIPTION <code>float</code> <p>The Fermi level, in eV</p> Source code in <code>pymatgen/io/espresso/outputs/pwxml.py</code> <pre><code>def calculate_efermi(self, **_) -&gt; float:\n    \"\"\"\n    Calculate the Fermi level\n\n    PWscf returns the Fermi level for all calculations and the cbm and vbm for\n    all insulators. These are stored in PWxml.efermi, PWxml.cbm, and PWxml.vbm.\n    However, for insulators, the Fermi level is often slightly off from the\n    exact mid-gap value.\n\n    If vbm and cbm are both undefined (metallic system), return the Fermi level\n    if vbm is defined and cbm isn't, it's usually a sign of an insulator\n    with as many bands as electrons (often nbnd isn't set in input)\n    Such calculations don't work with BSPlotter()\n\n    Returns:\n        The Fermi level, in eV\n    \"\"\"\n    if self.vbm is None or self.cbm is None:\n        return self.efermi\n    return (self.vbm + self.cbm) / 2\n</code></pre>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.UnconvergedPWxmlWarning","title":"<code>UnconvergedPWxmlWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>Warning for unconverged PWscf run from xml file</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.PWxmlParserError","title":"<code>PWxmlParserError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for PWxml parsing.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.InconsistentWithXMLError","title":"<code>InconsistentWithXMLError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for data from external files that is inconsistent with the XML file.</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.DifferentFromVASPWarning","title":"<code>DifferentFromVASPWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>Warning for differences between QE and VASP outputs</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.NotImplementedForQE","title":"<code>NotImplementedForQE</code>","text":"<p>               Bases: <code>Warning</code></p> <p>Warning for differences between QE and VASP outputs</p>"},{"location":"reference/pymatgen/io/espresso/outputs/pwxml/#pymatgen.io.espresso.outputs.pwxml.ZeroTotalEnergyWarning","title":"<code>ZeroTotalEnergyWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>Warning for zero total energy. Happens with bands/NSCF calcs in QE</p>"}]}